/*-----------------------------------------------------
 * Autogenerated Java class from XML definition.
 * Created Wed, 1 Jan 2025 13:57:49 -0600
 *-----------------------------------------------------*/

package waffleoRai_Files.maxis.ts3save.sim;

import java.io.IOException;
import java.io.Writer;
import java.util.ArrayList;
import java.util.List;

import org.w3c.dom.Element;

import waffleoRai_Containers.maxis.MaxisPropertyStream;
import waffleoRai_Containers.maxis.MaxisTypes;
import waffleoRai_Files.XMLReader;
import waffleoRai_Files.maxis.ts3enum.AlmaMater;
import waffleoRai_Files.maxis.ts3enum.CASAgeGenderFlags;
import waffleoRai_Files.maxis.ts3enum.DeathType;
import waffleoRai_Files.maxis.ts3enum.FavoriteFoodType;
import waffleoRai_Files.maxis.ts3enum.FavoriteMusicType;
import waffleoRai_Files.maxis.ts3enum.GraduationType;
import waffleoRai_Files.maxis.ts3enum.OccultTypes;
import waffleoRai_Files.maxis.ts3enum.ServiceType;
import waffleoRai_Files.maxis.ts3enum.SnowmanFlagType;
import waffleoRai_Files.maxis.ts3enum.TraitNames;
import waffleoRai_Files.maxis.ts3enum.VoiceVariationType;
import waffleoRai_Files.maxis.ts3enum.WorldName;
import waffleoRai_Files.maxis.ts3enum.Zodiac;
import waffleoRai_Files.maxis.ts3save.TS3Saveable;
import waffleoRai_Files.maxis.ts3save.books.ReadBookData;
import waffleoRai_Files.maxis.ts3save.career.AcademicDegreeManager;
import waffleoRai_Files.maxis.ts3save.career.CareerManager;
import waffleoRai_Files.maxis.ts3save.occult.OccultManager;
import waffleoRai_Files.maxis.ts3save.opportunities.OpportunityHistory;
import waffleoRai_Files.maxis.ts3save.pets.PetManager;
import waffleoRai_Files.maxis.ts3save.sim.buffs.BuffInstance;
import waffleoRai_Files.maxis.ts3save.sim.cas.OutfitCategoryMap;
import waffleoRai_Files.maxis.ts3save.sim.dreams.DnPExportData;
import waffleoRai_Files.maxis.ts3save.sim.event.LifeEventManager;
import waffleoRai_Files.maxis.ts3save.sim.immunity.HealthManager;
import waffleoRai_Files.maxis.ts3save.sim.skills.SingingInfo;
import waffleoRai_Files.maxis.ts3save.sim.skills.SkillManager;
import waffleoRai_Files.maxis.ts3save.sim.traits.TraitChipManager;
import waffleoRai_Files.maxis.ts3save.sim.traits.TraitManager;
import waffleoRai_Files.maxis.ts3save.travel.RelicStatTracking;
import waffleoRai_Files.maxis.ts3save.travel.TombStatTracking;
import waffleoRai_Files.maxis.ts3save.travel.VisaManager;
import waffleoRai_Utils.BufferReference;
import waffleoRai_Utils.FileBuffer;
import waffleoRai_Utils.StringUtils;

public class SimDescription extends TS3Saveable{
//TS3 Script: Sims3.Gameplay.CAS.SimDescription

	public static final int PSID_SIMDESCRIPTIONID = 0x687720A6;
	public static final int PSID_MSIMFLAGS = 0x68CDF632;
	public static final int PSID_AGINGYEARSSINCELASTAGETRANSITION = 0xCA2B6C5E;
	public static final int PSID_USERDAYSINCURRENTAGE = 0x0AE91A94;
	public static final int PSID_MSKINTONEKEY = 0x9C7DD2B7;
	public static final int PSID_MSKINTONEINDEX = 0xD9660BA6;
	public static final int PSID_MSECONDARYNORMALMAPWEIGHTS0 = 0xA97FDE46;
	public static final int PSID_MSECONDARYNORMALMAPWEIGHTS1 = 0xC9B54A78;
	public static final int PSID_MDEFAULTOUTFITKEY = 0xF93356EE;
	public static final int PSID_HAIRCOLORS0 = 0x5015F7E4;
	public static final int PSID_HAIRCOLORS1 = 0xF67D1A39;
	public static final int PSID_HAIRCOLORS2 = 0x93555682;
	public static final int PSID_HAIRCOLORS3 = 0x3EF0D82F;
	public static final int PSID_EYEBROWCOLOR = 0x6D70A3EF;
	public static final int PSID_BODYHAIRCOLOR = 0x6D70A3F0;
	public static final int PSID_FACIALHAIRCOLORS0 = 0xFAE19FEC;
	public static final int PSID_FACIALHAIRCOLORS1 = 0xA196E161;
	public static final int PSID_FACIALHAIRCOLORS2 = 0xFDD0E82A;
	public static final int PSID_FACIALHAIRCOLORS3 = 0xE9BC8037;
	public static final int PSID_BEARDUSESHAIRCOLOR = 0x077DCE7E;
	public static final int PSID_EYEBROWSUSEHAIRCOLOR = 0xCA154FA7;
	public static final int PSID_BODYHAIRUSESHAIRCOLOR = 0xCA154FA8;
	public static final int PSID_PROPAGATEHAIRSTYLE = 0x3B20D499;
	public static final int PSID_MHOUSEHOLD = 0x846D3A8C;
	public static final int PSID_MFIRSTNAME = 0xEB5173A0;
	public static final int PSID_MLASTNAME = 0x7047CB14;
	public static final int PSID_MDEATHSTYLE = 0x66B568DC;
	public static final int PSID_ISNEVERSELECTABLE = 0x868ECFE1;
	public static final int PSID_AGINGENABLED = 0x2F8D4E9E;
	public static final int PSID_MLIFETIMEHAPPINESS = 0x09F6B39B;
	public static final int PSID_MSPENDABLEHAPPINESS = 0xD88B0E1E;
	public static final int PSID_MFAVOURITEMUSICTYPE = 0x1672CF33;
	public static final int PSID_MFAVOURITEFOODTYPE = 0x35F0B67E;
	public static final int PSID_MFAVOURITECOLORARGB = 0x90254F2F;
	public static final int PSID_MBIO = 0x2699C285;
	public static final int PSID_MZODIACSIGN = 0x0A84EDF4;
	public static final int PSID_ALMAMATER = 0x0AE919CA;
	public static final int PSID_MALMAMATERNAME = 0x0AF27447;
	public static final int PSID_GRADUATIONTYPE = 0x0AE919C6;
	public static final int PSID_SERVICEHISTORY = 0xDE7FEED6;
	public static final int PSID_MARRYABLE = 0x30301674;
	public static final int PSID_CANBEKILLEDONJOB = 0x91CC2739;
	public static final int PSID_ISGHOST = 0x07CA2445;
	public static final int PSID_CONTACTABLE = 0x0626FE7E;
	public static final int PSID_ISPREGNANT = 0x1AFE5FD6;
	public static final int PSID_ISVISUALLYPREGNANT = 0x62FEAF35;
	public static final int PSID_ALIENDNAPERCENTAGE = 0x0DE5AE9C;
	public static final int PSID_MINITIALSHAPE = 0xA736A68A;
	public static final int PSID_MCURRENTSHAPE = 0x96FD9CC7;
	public static final int PSID_MFITNESSSHAPEDELTA = 0x11CAECE8;
	public static final int PSID_MWEIGHTSHAPEDELTA = 0xF3B138A6;
	public static final int PSID_MSHAPEDELTAMULTIPLIER = 0x6C525E41;
	public static final int PSID_MVOICEVARIATION = 0x77E12398;
	public static final int PSID_MVOICEPITCHMODIFIER = 0x45BF24C2;
	public static final int PSID_MGENETICHAIRSTYLEKEY = 0xEEF197F6;
	public static final int PSID_MGENETICBODYHAIRSTYLEKEYS0 = 0x0B863570;
	public static final int PSID_MGENETICBODYHAIRSTYLEKEYS1 = 0x0B863571;
	public static final int PSID_MGENETICBODYHAIRSTYLEKEYS2 = 0x0B863572;
	public static final int PSID_MGENETICBODYHAIRSTYLEKEYS3 = 0x0B863573;
	public static final int PSID_MGENETICBODYHAIRSTYLEKEYS4 = 0x0B863574;
	public static final int PSID_MGENETICBODYHAIRSTYLEKEYS5 = 0x0B863575;
	public static final int PSID_MGENETICBODYHAIRSTYLEKEYS6 = 0x0B863576;
	public static final int PSID_MGENETICBODYHAIRSTYLEKEYS7 = 0x0B863577;
	public static final int PSID_MHOMEWORLD = 0x8E21D930;
	public static final int PSID_MOUTFITS = 0x5853C67A;
	public static final int PSID_MSPECIALOUTFITINDICES = 0xBBE2002D;
	public static final int PSID_TRAITCOUNT = 0x5B6A3BBD;
	public static final int PSID_TRAITGUIDS = 0x6979B0FB;
	public static final int PSID_TRAITMANAGER = 0x093E2543;
	public static final int PSID_MGENEALOGY = 0x7AA078C4;
	public static final int PSID_LIFETIMEWISH = 0x84205551;
	public static final int PSID_HASCOMPLETEDLIFETIMEWISH = 0x86F6F456;
	public static final int PSID_OCCULTTYPE = 0x0D819F66;
	public static final int PSID_SSUPERNATURALVERSIONNUMBER = 0x0D819A00;
	public static final int PSID_MOCCULTTYPE = 0x0D819A01;
	public static final int PSID_SKILLMANAGER = 0x8D31A167;
	public static final int PSID_CAREERMANAGER = 0xE584E282;
	public static final int PSID_VISAMANAGER = 0x0E8446CB;
	public static final int PSID_CELEBRITYMANAGER = 0x0E8446CC;
	public static final int PSID_LIFEEVENTMANAGER = 0x723F28C2;
	public static final int PSID_OCCULTMANAGER = 0x08BC89C9;
	public static final int PSID_HEALTHMANAGER = 0x0D43BBE6;
	public static final int PSID_MREPUTATION = 0x08BC89D0;
	public static final int PSID_MIDLIFECRISISMANAGER = 0x0AD3E939;
	public static final int PSID_PETMANAGER = 0xF417D949;
	public static final int PSID_READBOOKCOUNT = 0x7C15700F;
	public static final int PSID_READBOOKDATALIST = 0x44E18648;
	public static final int PSID_READBOOKDATABASE = 0x9058096A;
	public static final int PSID_PREGNANCY = 0x3F70BCAA;
	public static final int PSID_OPPORTUNITYHISTORY = 0xE4019998;
	public static final int PSID_NEEDSOPPORTUNITYIMPORT = 0x08E03EE5;
	public static final int PSID_DNPEXPORTDATA = 0xB529395B;
	public static final int PSID_RELICSTATS = 0x08859134;
	public static final int PSID_TOMBSTATS = 0xFC5C05D4;
	public static final int PSID_TRAVELBUFFS = 0x08895C51;
	public static final int PSID_MPREFERREDVEHICLEGUID = 0xE4A56EC4;
	public static final int PSID_SINGING = 0x08AE7446;
	public static final int PSID_SOCIALEXPTRAVELING = 0x00000000;
	public static final int PSID_KNOWNSNOWMANTYPES = 0xCF299C98;
	public static final int PSID_SURGERYBLENDS = 0x00000000;
	public static final int PSID_DEGREEMANAGER = 0x0E559B86;
	public static final int PSID_MTRAITCHIPMANAGER = 0x93568173;

	private static final String XMLKEY_SIMDESCRIPTIONID = "SimDescriptionId";
	private static final String XMLKEY_MSIMFLAGS = "SimFlags";
	private static final String XMLKEY_AGINGYEARSSINCELASTAGETRANSITION = "AgingYearsSinceLastAgeTransition";
	private static final String XMLKEY_USERDAYSINCURRENTAGE = "UserDaysInCurrentAge";
	private static final String XMLKEY_MSKINTONEKEY = "SkinToneKey";
	private static final String XMLKEY_MSKINTONEINDEX = "SkinToneIndex";
	private static final String XMLKEY_MSECONDARYNORMALMAPWEIGHTS0 = "SecondaryNormalMapWeights0";
	private static final String XMLKEY_MSECONDARYNORMALMAPWEIGHTS1 = "SecondaryNormalMapWeights1";
	private static final String XMLKEY_MDEFAULTOUTFITKEY = "DefaultOutfitKey";
	private static final String XMLKEY_BEARDUSESHAIRCOLOR = "BeardUsesHairColor";
	private static final String XMLKEY_EYEBROWSUSEHAIRCOLOR = "EyebrowsUseHairColor";
	private static final String XMLKEY_BODYHAIRUSESHAIRCOLOR = "BodyHairUsesHairColor";
	private static final String XMLKEY_PROPAGATEHAIRSTYLE = "PropagateHairStyle";
	private static final String XMLKEY_MHOUSEHOLD = "Household";
	private static final String XMLKEY_MFIRSTNAME = "FirstName";
	private static final String XMLKEY_MLASTNAME = "LastName";
	private static final String XMLKEY_MDEATHSTYLE = "DeathStyle";
	private static final String XMLKEY_ISNEVERSELECTABLE = "IsNeverSelectable";
	private static final String XMLKEY_AGINGENABLED = "AgingEnabled";
	private static final String XMLKEY_MLIFETIMEHAPPINESS = "LifetimeHappiness";
	private static final String XMLKEY_MSPENDABLEHAPPINESS = "SpendableHappiness";
	private static final String XMLKEY_MFAVOURITEMUSICTYPE = "FavouriteMusicType";
	private static final String XMLKEY_MFAVOURITEFOODTYPE = "FavouriteFoodType";
	private static final String XMLKEY_MFAVOURITECOLORARGB = "FavouriteColorARGB";
	private static final String XMLKEY_MBIO = "BioText";
	private static final String XMLKEY_MZODIACSIGN = "ZodiacSign";
	private static final String XMLKEY_ALMAMATER = "AlmaMaterType";
	private static final String XMLKEY_MALMAMATERNAME = "AlmaMaterName";
	private static final String XMLKEY_GRADUATIONTYPE = "GraduationType";
	private static final String XMLKEY_SERVICEHISTORY = "ServiceHistory";
	private static final String XMLKEY_MARRYABLE = "Marryable";
	private static final String XMLKEY_CANBEKILLEDONJOB = "CanBeKilledOnJob";
	private static final String XMLKEY_ISGHOST = "IsGhost";
	private static final String XMLKEY_CONTACTABLE = "Contactable";
	private static final String XMLKEY_ISPREGNANT = "IsPregnant";
	private static final String XMLKEY_ISVISUALLYPREGNANT = "IsVisuallyPregnant";
	private static final String XMLKEY_ALIENDNAPERCENTAGE = "AlienDNAPercentage";
	private static final String XMLKEY_MINITIALSHAPE = "InitialShape";
	private static final String XMLKEY_MCURRENTSHAPE = "CurrentShape";
	private static final String XMLKEY_MFITNESSSHAPEDELTA = "FitnessShapeDelta";
	private static final String XMLKEY_MWEIGHTSHAPEDELTA = "WeightShapeDelta";
	private static final String XMLKEY_MSHAPEDELTAMULTIPLIER = "ShapeDeltaMultiplier";
	private static final String XMLKEY_MVOICEVARIATION = "VoiceVariation";
	private static final String XMLKEY_MVOICEPITCHMODIFIER = "VoicePitchModifier";
	private static final String XMLKEY_MGENETICHAIRSTYLEKEY = "GeneticHairstyleKey";
	private static final String XMLKEY_MHOMEWORLD = "HomeWorld";
	private static final String XMLKEY_MOUTFITS = "Outfits";
	private static final String XMLKEY_MSPECIALOUTFITINDICES = "SpecialOutfitIndices";
	private static final String XMLKEY_TRAITMANAGER = "TraitManager";
	private static final String XMLKEY_MGENEALOGY = "Genealogy";
	private static final String XMLKEY_LIFETIMEWISH = "LifetimeWish";
	private static final String XMLKEY_HASCOMPLETEDLIFETIMEWISH = "HasCompletedLifetimeWish";
	private static final String XMLKEY_OCCULTTYPE = "OccultType";
	private static final String XMLKEY_SSUPERNATURALVERSIONNUMBER = "SupernaturalVersionNumber";
	private static final String XMLKEY_MOCCULTTYPE = "MOccultType";
	private static final String XMLKEY_SKILLMANAGER = "SkillManager";
	private static final String XMLKEY_CAREERMANAGER = "CareerManager";
	private static final String XMLKEY_VISAMANAGER = "VisaManager";
	private static final String XMLKEY_CELEBRITYMANAGER = "CelebrityManager";
	private static final String XMLKEY_LIFEEVENTMANAGER = "LifeEventManager";
	private static final String XMLKEY_OCCULTMANAGER = "OccultManager";
	private static final String XMLKEY_HEALTHMANAGER = "HealthManager";
	private static final String XMLKEY_MREPUTATION = "Reputation";
	private static final String XMLKEY_MIDLIFECRISISMANAGER = "MidlifeCrisisManager";
	private static final String XMLKEY_PETMANAGER = "PetManager";
	private static final String XMLKEY_READBOOKDATALIST = "ReadBookDataList";
	private static final String XMLKEY_PREGNANCY = "Pregnancy";
	private static final String XMLKEY_OPPORTUNITYHISTORY = "OpportunityHistory";
	private static final String XMLKEY_NEEDSOPPORTUNITYIMPORT = "NeedsOpportunityImport";
	private static final String XMLKEY_DNPEXPORTDATA = "DnPExportData";
	private static final String XMLKEY_RELICSTATS = "RelicStats";
	private static final String XMLKEY_TOMBSTATS = "TombStats";
	private static final String XMLKEY_TRAVELBUFFS = "TravelBuffs";
	private static final String XMLKEY_MPREFERREDVEHICLEGUID = "PreferredVehicleGuid";
	private static final String XMLKEY_SINGING = "Singing";
	private static final String XMLKEY_SOCIALEXPTRAVELING = "SocialExpTraveling";
	private static final String XMLKEY_KNOWNSNOWMANTYPES = "KnownSnowmanTypes";
	private static final String XMLKEY_SURGERYBLENDS = "SurgeryBlends";
	private static final String XMLKEY_DEGREEMANAGER = "DegreeManager";
	private static final String XMLKEY_MTRAITCHIPMANAGER = "TraitChipManager";

	public long simDescriptionId;
	public int mSimFlags;
	public float agingYearsSinceLastAgeTransition;
	public int userDaysInCurrentAge;
	public int mSkinToneKey;
	public float mSkinToneIndex;
	public float mSecondaryNormalMapWeights0;
	public float mSecondaryNormalMapWeights1;
	public int mDefaultOutfitKey;
	public int[] hairColors0;
	public int[] hairColors1;
	public int[] hairColors2;
	public int[] hairColors3;
	public int[] eyebrowColor;
	public int[] bodyHairColor;
	public int[] facialHairColors0;
	public int[] facialHairColors1;
	public int[] facialHairColors2;
	public int[] facialHairColors3;
	public int beardUsesHairColor;
	public int eyebrowsUseHairColor;
	public int bodyHairUsesHairColor;
	public int propagateHairStyle;
	public long mHousehold;
	public String mFirstName;
	public String mLastName;
	public int mDeathStyle;
	public boolean isNeverSelectable;
	public boolean agingEnabled;
	public float mLifetimeHappiness;
	public float mSpendableHappiness;
	public int mFavouriteMusicType;
	public int mFavouriteFoodType;
	public int mFavouriteColorARGB;
	public String mBio;
	public int mZodiacSign;
	public int almaMater;
	public String mAlmaMaterName;
	public int graduationType;
	public long serviceHistory;
	public boolean marryable;
	public boolean canBeKilledOnJob;
	public boolean isGhost;
	public boolean contactable;
	public boolean isPregnant;
	public boolean isVisuallyPregnant;
	public float alienDNAPercentage;
	public BodyShape mInitialShape;
	public BodyShape mCurrentShape;
	public float mFitnessShapeDelta;
	public float mWeightShapeDelta;
	public float mShapeDeltaMultiplier;
	public int mVoiceVariation;
	public float mVoicePitchModifier;
	public int mGeneticHairstyleKey;
	public int mGeneticBodyhairStyleKeys0;
	public int mGeneticBodyhairStyleKeys1;
	public int mGeneticBodyhairStyleKeys2;
	public int mGeneticBodyhairStyleKeys3;
	public int mGeneticBodyhairStyleKeys4;
	public int mGeneticBodyhairStyleKeys5;
	public int mGeneticBodyhairStyleKeys6;
	public int mGeneticBodyhairStyleKeys7;
	public int mHomeWorld;
	public OutfitCategoryMap mOutfits;
	public SpecialOutfitIndices mSpecialOutfitIndices;
	public int traitCount;
	public long[] traitGuids;
	public TraitManager traitManager;
	public Genealogy mGenealogy;
	public int lifetimeWish;
	public boolean hasCompletedLifetimeWish;
	public int occultType;
	public int sSupernaturalVersionNumber;
	public int mOccultType;
	public SkillManager skillManager;
	public CareerManager careerManager;
	public VisaManager visaManager;
	public CelebrityManager celebrityManager;
	public LifeEventManager lifeEventManager;
	public OccultManager occultManager;
	public HealthManager healthManager;
	public ReputationStatistics mReputation;
	public MidlifeCrisisManager midlifeCrisisManager;
	public PetManager petManager;
	public int readBookCount;
	public ArrayList<ReadBookInstance> readBookDataList = new ArrayList<ReadBookInstance>();
	public Pregnancy pregnancy;
	public OpportunityHistory opportunityHistory;
	public boolean needsOpportunityImport;
	public DnPExportData dnPExportData;
	public RelicStatTracking relicStats;
	public TombStatTracking tombStats;
	public TravelBuffList travelBuffs;
	public int mPreferredVehicleGuid;
	public SingingInfo singing;
	public SocialExpTraveling socialExpTraveling;
	public byte knownSnowmanTypes;
	public SurgeryBlends surgeryBlends;
	public AcademicDegreeManager degreeManager;
	public TraitChipManager mTraitChipManager;

	public SimDescription() {
		xmlNodeName = "SimDescription";
		baseSize = 275;
	}
	
	public String genXmlFileName() {
		String ln = this.mLastName.replace(" ", "");
		ln = ln.replace("-", "");
		String fn = this.mFirstName.replace(" ", "");
		fn = fn.replace("-", "");
		String idstr = String.format("%016x", simDescriptionId);
		
		return ln + "_" + fn + "_" + idstr;
	}
	
	/*----- Inner Classes -----*/

	public static class ReadBookInstance extends TS3Saveable{

		private static final String XMLKEY_READBOOKKEY = "ReadBookKey";
		private static final String XMLKEY_READBOOKDATA = "ReadBookData";

		public String readBookKey;
		public ReadBookData readBookData;

		public int psidKey = 0;
		public int psidData = 0;

		public ReadBookInstance() {
			xmlNodeName = "ReadBookInstance";
			baseSize = 4;
		}
		
		/*----- Read -----*/
		
		protected boolean readBinary_internal(BufferReference dat) {
			if(dat == null) return false;
			
			readBookKey = MaxisTypes.readMaxisString(dat);
			readBookData = ReadBookData.readBinary(dat);

			return true;
		}
		
		protected boolean readXMLNode_internal(Element xml_element) {
			if(xml_element == null) return false;
			String nn = xml_element.getNodeName();
			if(nn == null) return false;
			if(!nn.equals(xmlNodeName)) return false;
			
			String aval = null;
			Element child = null;
			aval = xml_element.getAttribute(XMLKEY_READBOOKKEY);
			if(aval != null) readBookKey = aval;
			child = XMLReader.getFirstChildElementWithTagAndAttribute(xml_element, "ReadBookData", "VarName", XMLKEY_READBOOKDATA);
			if(child != null) readBookData = ReadBookData.readXMLNode(child);

			return true;
		}
		
		protected boolean readPropertyStream_internal(MaxisPropertyStream stream) {
			if(stream == null) return false;
			readBookKey = stream.getFieldAsString(psidKey);
			readBookData = ReadBookData.readPropertyStream(stream.getChildStream(psidData));
			return true;
		}
		
		public static ReadBookInstance readBinary(BufferReference dat) {
			if(dat == null) return null;
			ReadBookInstance str = new ReadBookInstance();
			if(!str.readBinary_internal(dat)) return null;
			return str;
		}
		
		public static ReadBookInstance readXMLNode(Element xml_element) {
			if(xml_element == null) return null;
			ReadBookInstance str = new ReadBookInstance();
			if(!str.readXMLNode_internal(xml_element)) return null;
			return str;
		}
		
		public static ReadBookInstance readPropertyStream(BufferReference dat, boolean byteOrder, int verFieldSize) {
			if(dat == null) return null;
			MaxisPropertyStream stream = MaxisPropertyStream.openForRead(dat, byteOrder, verFieldSize);
			return readPropertyStream(stream);
		}
		
		public static ReadBookInstance readPropertyStream(MaxisPropertyStream stream) {
			if(stream == null) return null;
			ReadBookInstance str = new ReadBookInstance();
			if(!str.readPropertyStream_internal(stream));
			return str;
		}
		
		/*----- Write -----*/
		
		public int getBinarySize() {
			int size = baseSize;
			size += (readBookKey.length() << 1);
			size += readBookData.getBinarySize();
			return size;
		}
		
		public FileBuffer writeBinary(boolean byteOrder) {
			FileBuffer buff = new FileBuffer(getBinarySize(), byteOrder);
			writeBinaryTo(buff);
			return buff;
		}
		
		public int writeBinaryTo(FileBuffer target) {
			if(target == null) return 0;
			long stPos = target.getFileSize();
			
			MaxisTypes.serializeMaxisStringTo( readBookKey, target);
			readBookData.writeBinaryTo(target);

			return (int)(target.getFileSize() - stPos);
		}
	
		public void writeXMLNode(Writer out, String indent) throws IOException {
			writeXMLNode(out, indent, null);
		}
		
		public void writeXMLNode(Writer out, String indent, String varName) throws IOException {
			if(out == null) return;
			if(indent == null) indent = "";
			
			out.write(indent);
			out.write(String.format("<%s", xmlNodeName));
			if(varName != null){
				out.write(String.format(" VarName=\"%s\"", varName));
			}
			out.write(String.format(" %s=\"%s\"", XMLKEY_READBOOKKEY, readBookKey));
			out.write(">\n");
			readBookData.writeXMLNode(out, indent + "\t", XMLKEY_READBOOKDATA);
			out.write(indent);
			out.write(String.format("</%s>\n", xmlNodeName));

		}
	
		public void addToPropertyStream(MaxisPropertyStream ps) {	
			if(ps == null) return;
			boolean byte_order = ps.getByteOrder();
			int verFieldSize = ps.getVersionFieldSize();
			ps.addString(readBookKey, psidKey);
			ps.addChildStream(readBookData.toPropertyStream(byte_order, verFieldSize), psidData);
		}
		
	}

	public static class TravelBuffList extends TS3Saveable{

		public static final int PSID_TRAVELBUFFCOUNT = 0x00000000;
		public static final int PSID_TRAVELBUFFLIST = 0x00000001;

		private static final String XMLKEY_TRAVELBUFFCOUNT = "TravelBuffCount";
		private static final String XMLKEY_TRAVELBUFFLIST = "TravelBuffList";

		public int travelBuffCount;
		public ArrayList<BuffInstance> travelBuffList = new ArrayList<BuffInstance>();

		public TravelBuffList() {
			xmlNodeName = "TravelBuffList";
			baseSize = 4;
		}
		
		/*----- Read -----*/
		
		protected boolean readBinary_internal(BufferReference dat) {
			if(dat == null) return false;
			
			travelBuffCount = dat.nextInt();
			travelBuffList.ensureCapacity(travelBuffCount);
			for(int i = 0; i < travelBuffCount; i++){
				BuffInstance travelBuff = BuffInstance.readBinary(dat);
				if(travelBuff != null) travelBuffList.add(travelBuff);
			}

			return true;
		}
		
		protected boolean readXMLNode_internal(Element xml_element) {
			if(xml_element == null) return false;
			String nn = xml_element.getNodeName();
			if(nn == null) return false;
			if(!nn.equals(xmlNodeName)) return false;
			
			String aval = null;
			Element child = null;
			aval = xml_element.getAttribute(XMLKEY_TRAVELBUFFCOUNT);
			if(aval != null) travelBuffCount = StringUtils.parseSignedInt(aval);
			child = XMLReader.getFirstChildElementWithTagAndAttribute(xml_element, "List", "VarName", XMLKEY_TRAVELBUFFLIST);
			if(child != null){
				travelBuffList.ensureCapacity(travelBuffCount);
				List<Element> gclist = XMLReader.getChildElementsWithTag(child, "BuffInstance");
				for(Element gc : gclist){
					travelBuffList.add(BuffInstance.readXMLNode(gc));
				}
			}

			return true;
		}
		
		protected boolean readPropertyStream_internal(MaxisPropertyStream stream) {
			if(stream == null) return false;
			
			travelBuffCount = stream.getFieldAsInt(PSID_TRAVELBUFFCOUNT, true);
			travelBuffList.ensureCapacity(travelBuffCount);
			for(int i = 0; i < travelBuffCount; i++){
				BuffInstance travelBuff = BuffInstance.readPropertyStream(stream.getChildStream(PSID_TRAVELBUFFLIST+i));
				if(travelBuff != null) travelBuffList.add(travelBuff);
			}

			return true;
		}
		
		public static TravelBuffList readBinary(BufferReference dat) {
			if(dat == null) return null;
			TravelBuffList str = new TravelBuffList();
			if(!str.readBinary_internal(dat)) return null;
			return str;
		}
		
		public static TravelBuffList readXMLNode(Element xml_element) {
			if(xml_element == null) return null;
			TravelBuffList str = new TravelBuffList();
			if(!str.readXMLNode_internal(xml_element)) return null;
			return str;
		}
		
		public static TravelBuffList readPropertyStream(BufferReference dat, boolean byteOrder, int verFieldSize) {
			if(dat == null) return null;
			MaxisPropertyStream stream = MaxisPropertyStream.openForRead(dat, byteOrder, verFieldSize);
			return readPropertyStream(stream);
		}
		
		public static TravelBuffList readPropertyStream(MaxisPropertyStream stream) {
			if(stream == null) return null;
			TravelBuffList str = new TravelBuffList();
			if(!str.readPropertyStream_internal(stream));
			return str;
		}
		
		/*----- Write -----*/
		
		public int getBinarySize() {
			int size = baseSize;
			for(BuffInstance travelBuff : travelBuffList){
				size += travelBuff.getBinarySize();
			}
			return size;
		}
		
		public FileBuffer writeBinary(boolean byteOrder) {
			FileBuffer buff = new FileBuffer(getBinarySize(), byteOrder);
			writeBinaryTo(buff);
			return buff;
		}
		
		public int writeBinaryTo(FileBuffer target) {
			if(target == null) return 0;
			long stPos = target.getFileSize();
			
			travelBuffCount = travelBuffList.size();
			target.addToFile(travelBuffCount);
			for(BuffInstance travelBuff : travelBuffList){
				travelBuff.writeBinaryTo(target);
			}

			return (int)(target.getFileSize() - stPos);
		}
	
		public void writeXMLNode(Writer out, String indent) throws IOException {
			writeXMLNode(out, indent, null);
		}
		
		public void writeXMLNode(Writer out, String indent, String varName) throws IOException {
			if(out == null) return;
			if(indent == null) indent = "";
			
			travelBuffCount = travelBuffList.size();
			out.write(indent);
			out.write(String.format("<%s", xmlNodeName));
			if(varName != null){
				out.write(String.format(" VarName=\"%s\"", varName));
			}
			out.write(String.format(" %s=\"%d\"", XMLKEY_TRAVELBUFFCOUNT, travelBuffCount));
			out.write(">\n");
			out.write(indent + "\t<List ");
			out.write(String.format(" VarName=\"%s\">\n", XMLKEY_TRAVELBUFFLIST));
			for(BuffInstance travelBuff : travelBuffList){
				travelBuff.writeXMLNode(out, indent + "\t\t", null);
			}
			out.write(indent + "\t</List>\n");
			out.write(indent);
			out.write(String.format("</%s>\n", xmlNodeName));

		}
	
		public void addToPropertyStream(MaxisPropertyStream ps) {	
			if(ps == null) return;
			boolean byte_order = ps.getByteOrder();
			int verFieldSize = ps.getVersionFieldSize();
			
			travelBuffCount = travelBuffList.size();
			int i = 0;
			ps.addInt(travelBuffCount, PSID_TRAVELBUFFCOUNT, true);
			i = 0;
			for(BuffInstance travelBuff : travelBuffList){
				ps.addChildStream(travelBuff.toPropertyStream(byte_order, verFieldSize), PSID_TRAVELBUFFLIST+i);
				i++;
			}
		}

	}

	/*----- Read -----*/
	
	protected boolean readBinary_internal(BufferReference dat) {
		if(dat == null) return false;
		
		simDescriptionId = dat.nextLong();
		mSimFlags = dat.nextInt();
		agingYearsSinceLastAgeTransition = Float.intBitsToFloat(dat.nextInt());
		userDaysInCurrentAge = dat.nextInt();
		mSkinToneKey = dat.nextInt();
		mSkinToneIndex = Float.intBitsToFloat(dat.nextInt());
		mSecondaryNormalMapWeights0 = Float.intBitsToFloat(dat.nextInt());
		mSecondaryNormalMapWeights1 = Float.intBitsToFloat(dat.nextInt());
		mDefaultOutfitKey = dat.nextInt();
		hairColors0 = new int[3];
		for(int i = 0; i < 3; i++){
			hairColors0[i] = dat.nextInt();
		}
		hairColors1 = new int[3];
		for(int i = 0; i < 3; i++){
			hairColors1[i] = dat.nextInt();
		}
		hairColors2 = new int[3];
		for(int i = 0; i < 3; i++){
			hairColors2[i] = dat.nextInt();
		}
		hairColors3 = new int[3];
		for(int i = 0; i < 3; i++){
			hairColors3[i] = dat.nextInt();
		}
		eyebrowColor = new int[3];
		for(int i = 0; i < 3; i++){
			eyebrowColor[i] = dat.nextInt();
		}
		bodyHairColor = new int[3];
		for(int i = 0; i < 3; i++){
			bodyHairColor[i] = dat.nextInt();
		}
		facialHairColors0 = new int[3];
		for(int i = 0; i < 3; i++){
			facialHairColors0[i] = dat.nextInt();
		}
		facialHairColors1 = new int[3];
		for(int i = 0; i < 3; i++){
			facialHairColors1[i] = dat.nextInt();
		}
		facialHairColors2 = new int[3];
		for(int i = 0; i < 3; i++){
			facialHairColors2[i] = dat.nextInt();
		}
		facialHairColors3 = new int[3];
		for(int i = 0; i < 3; i++){
			facialHairColors3[i] = dat.nextInt();
		}
		beardUsesHairColor = dat.nextInt();
		eyebrowsUseHairColor = dat.nextInt();
		bodyHairUsesHairColor = dat.nextInt();
		propagateHairStyle = dat.nextInt();
		mHousehold = dat.nextLong();
		mFirstName = MaxisTypes.readMaxisString(dat);
		mLastName = MaxisTypes.readMaxisString(dat);
		mDeathStyle = dat.nextInt();
		isNeverSelectable = MaxisTypes.readBinaryBool(dat);
		agingEnabled = MaxisTypes.readBinaryBool(dat);
		mLifetimeHappiness = Float.intBitsToFloat(dat.nextInt());
		mSpendableHappiness = Float.intBitsToFloat(dat.nextInt());
		mFavouriteMusicType = dat.nextInt();
		mFavouriteFoodType = dat.nextInt();
		mFavouriteColorARGB = dat.nextInt();
		mBio = MaxisTypes.readMaxisString(dat);
		mZodiacSign = dat.nextInt();
		almaMater = dat.nextInt();
		mAlmaMaterName = MaxisTypes.readMaxisString(dat);
		graduationType = dat.nextInt();
		serviceHistory = dat.nextLong();
		marryable = MaxisTypes.readBinaryBool(dat);
		canBeKilledOnJob = MaxisTypes.readBinaryBool(dat);
		isGhost = MaxisTypes.readBinaryBool(dat);
		contactable = MaxisTypes.readBinaryBool(dat);
		isPregnant = MaxisTypes.readBinaryBool(dat);
		isVisuallyPregnant = MaxisTypes.readBinaryBool(dat);
		alienDNAPercentage = Float.intBitsToFloat(dat.nextInt());
		mInitialShape = BodyShape.readBinary(dat);
		mCurrentShape = BodyShape.readBinary(dat);
		mFitnessShapeDelta = Float.intBitsToFloat(dat.nextInt());
		mWeightShapeDelta = Float.intBitsToFloat(dat.nextInt());
		mShapeDeltaMultiplier = Float.intBitsToFloat(dat.nextInt());
		mVoiceVariation = dat.nextInt();
		mVoicePitchModifier = Float.intBitsToFloat(dat.nextInt());
		mGeneticHairstyleKey = dat.nextInt();
		mGeneticBodyhairStyleKeys0 = dat.nextInt();
		mGeneticBodyhairStyleKeys1 = dat.nextInt();
		mGeneticBodyhairStyleKeys2 = dat.nextInt();
		mGeneticBodyhairStyleKeys3 = dat.nextInt();
		mGeneticBodyhairStyleKeys4 = dat.nextInt();
		mGeneticBodyhairStyleKeys5 = dat.nextInt();
		mGeneticBodyhairStyleKeys6 = dat.nextInt();
		mGeneticBodyhairStyleKeys7 = dat.nextInt();
		mHomeWorld = dat.nextInt();
		mOutfits = OutfitCategoryMap.readBinary(dat);
		mSpecialOutfitIndices = SpecialOutfitIndices.readBinary(dat);
		traitCount = dat.nextInt();
		traitGuids = new long[traitCount];
		for(int i = 0; i < traitCount; i++){
			traitGuids[i] = dat.nextLong();
		}
		traitManager = TraitManager.readBinary(dat);
		mGenealogy = Genealogy.readBinary(dat);
		lifetimeWish = dat.nextInt();
		hasCompletedLifetimeWish = MaxisTypes.readBinaryBool(dat);
		occultType = dat.nextInt();
		sSupernaturalVersionNumber = dat.nextInt();
		mOccultType = dat.nextInt();
		skillManager = SkillManager.readBinary(dat);
		careerManager = CareerManager.readBinary(dat);
		visaManager = VisaManager.readBinary(dat);
		celebrityManager = CelebrityManager.readBinary(dat);
		lifeEventManager = LifeEventManager.readBinary(dat);
		occultManager = OccultManager.readBinary(dat);
		healthManager = HealthManager.readBinary(dat);
		mReputation = ReputationStatistics.readBinary(dat);
		midlifeCrisisManager = MidlifeCrisisManager.readBinary(dat);
		petManager = PetManager.readBinary(dat);
		readBookCount = dat.nextInt();
		readBookDataList.ensureCapacity(readBookCount);
		for(int i = 0; i < readBookCount; i++){
			ReadBookInstance readBookData = ReadBookInstance.readBinary(dat);
			if(readBookData != null) readBookDataList.add(readBookData);
		}
		pregnancy = Pregnancy.readBinary(dat);
		opportunityHistory = OpportunityHistory.readBinary(dat);
		needsOpportunityImport = MaxisTypes.readBinaryBool(dat);
		dnPExportData = DnPExportData.readBinary(dat);
		relicStats = RelicStatTracking.readBinary(dat);
		tombStats = TombStatTracking.readBinary(dat);
		travelBuffs = TravelBuffList.readBinary(dat);
		mPreferredVehicleGuid = dat.nextInt();
		singing = SingingInfo.readBinary(dat);
		socialExpTraveling = SocialExpTraveling.readBinary(dat);
		knownSnowmanTypes = dat.nextByte();
		surgeryBlends = SurgeryBlends.readBinary(dat);
		degreeManager = AcademicDegreeManager.readBinary(dat);
		mTraitChipManager = TraitChipManager.readBinary(dat);

		return true;
	}
	
	private void readXml_Basics(Element descRoot) {
		//Node name should be "Biographical"
		Element xml_element = XMLReader.getFirstChildElementWithTag(descRoot, "Biographical");
		if(xml_element == null) return;
		
		String aval = null;
		aval = xml_element.getAttribute(XMLKEY_MSIMFLAGS);
		if(aval != null) mSimFlags = CASAgeGenderFlags.valueFromString(aval);
		aval = xml_element.getAttribute(XMLKEY_MHOUSEHOLD);
		if(aval != null) mHousehold = StringUtils.parseUnsignedLong(aval);
		aval = xml_element.getAttribute(XMLKEY_MFIRSTNAME);
		if(aval != null) mFirstName = aval;
		aval = xml_element.getAttribute(XMLKEY_MLASTNAME);
		if(aval != null) mLastName = aval;
		aval = xml_element.getAttribute(XMLKEY_MZODIACSIGN);
		if(aval != null) mZodiacSign = Zodiac.valueFromString(aval);
		aval = xml_element.getAttribute(XMLKEY_MHOMEWORLD);
		if(aval != null) mHomeWorld = WorldName.valueFromString(aval);
		
		//Bio
		Element child = XMLReader.getFirstChildElementWithTag(xml_element, XMLKEY_MBIO);
		if(child != null) {
			//TODO Put a function in XMLReader for getting the text
		}
	}
	
	private void readXml_Aging(Element descRoot) {
		//Node name should be "Aging"
		Element xml_element = XMLReader.getFirstChildElementWithTag(descRoot, "Aging");
		if(xml_element == null) return;
		
		String aval = null;
		aval = xml_element.getAttribute(XMLKEY_AGINGYEARSSINCELASTAGETRANSITION);
		if(aval != null) agingYearsSinceLastAgeTransition = (float)Double.parseDouble(aval);
		aval = xml_element.getAttribute(XMLKEY_USERDAYSINCURRENTAGE);
		if(aval != null) userDaysInCurrentAge = StringUtils.parseSignedInt(aval);
		aval = xml_element.getAttribute(XMLKEY_AGINGENABLED);
		if(aval != null) agingEnabled = Boolean.parseBoolean(aval);
	}
	
	private void readXmlSub_HairColor(Element xml_element, int[] clrData) {
		String aval = null;
		aval = xml_element.getAttribute("GeneticARGB");
		if(aval != null) clrData[0] = StringUtils.parseUnsignedInt(aval);
		aval = xml_element.getAttribute("DyeARGB");
		if(aval != null) clrData[1] = StringUtils.parseUnsignedInt(aval);
		aval = xml_element.getAttribute("UseDye");
		boolean useDye = false;
		if(aval != null) useDye = Boolean.parseBoolean(aval);
		if(useDye) clrData[2] = 1;
		else clrData[2] = 0;
	}
	
	private void readXml_Physical(Element descRoot) {
		Element xml_element = XMLReader.getFirstChildElementWithTag(descRoot, "PhysAttributes");
		if(xml_element == null) return;
		
		String aval = null;
		
		//Common
		aval = xml_element.getAttribute(XMLKEY_ALIENDNAPERCENTAGE);
		if(aval != null) alienDNAPercentage = (float)Double.parseDouble(aval);
		aval = xml_element.getAttribute(XMLKEY_MVOICEVARIATION);
		if(aval != null) mVoiceVariation = VoiceVariationType.valueFromString(aval);
		aval = xml_element.getAttribute(XMLKEY_MVOICEPITCHMODIFIER);
		if(aval != null) mVoicePitchModifier = (float)Double.parseDouble(aval);

		//Skin
		Element child = XMLReader.getFirstChildElementWithTag(xml_element, "Skin");
		if(child != null) {
			aval = child.getAttribute(XMLKEY_MSKINTONEKEY);
			if(aval != null) mSkinToneKey = StringUtils.parseSignedInt(aval);
			aval = child.getAttribute(XMLKEY_MSKINTONEINDEX);
			if(aval != null) mSkinToneIndex = (float)Double.parseDouble(aval);
		}

		//Hair
		child = XMLReader.getFirstChildElementWithTag(xml_element, "Hair");
		if(child != null) {
			Element grandchild = XMLReader.getFirstChildElementWithTag(child, "Head");
			if(grandchild != null) {
				aval = grandchild.getAttribute(XMLKEY_MGENETICHAIRSTYLEKEY);
				if(aval != null) mGeneticHairstyleKey = StringUtils.parseSignedInt(aval);
				
				grandchild = XMLReader.getFirstChildElementWithTag(grandchild, "HairColors");
				if(grandchild != null) {
					int i = 0;
					List<Element> gggcList = XMLReader.getChildElementsWithTag(grandchild, "HairColor");
					for(Element gggc : gggcList) {
						switch(i) {
						case 0: readXmlSub_HairColor(gggc, hairColors0); break;
						case 1: readXmlSub_HairColor(gggc, hairColors1); break;
						case 2: readXmlSub_HairColor(gggc, hairColors2); break;
						case 3: readXmlSub_HairColor(gggc, hairColors3); break;
						}
						i++;
					}
				}
			}
			
			grandchild = XMLReader.getFirstChildElementWithTag(child, "Face");
			if(grandchild != null) {
				Element ggc = XMLReader.getFirstChildElementWithTag(grandchild, "Eyebrows");
				if(ggc != null) {
					aval = ggc.getAttribute(XMLKEY_EYEBROWSUSEHAIRCOLOR);
					if(aval != null) {
						boolean b = Boolean.parseBoolean(aval);
						eyebrowsUseHairColor = b?1:0;
					}
					
					Element gggc = XMLReader.getFirstChildElementWithTag(grandchild, "HairColor");
					readXmlSub_HairColor(gggc, eyebrowColor);
				}
				
				ggc = XMLReader.getFirstChildElementWithTag(grandchild, "FacialHair");
				if(ggc != null) {
					aval = ggc.getAttribute(XMLKEY_BEARDUSESHAIRCOLOR);
					if(aval != null) {
						boolean b = Boolean.parseBoolean(aval);
						beardUsesHairColor = b?1:0;
					}
					
					Element gggc = XMLReader.getFirstChildElementWithTag(ggc, "HairColors");
					if(gggc != null) {
						int i = 0;
						List<Element> ggggcList = XMLReader.getChildElementsWithTag(gggc, "HairColor");
						for(Element ggggc : ggggcList) {
							switch(i) {
							case 0: readXmlSub_HairColor(ggggc, facialHairColors0); break;
							case 1: readXmlSub_HairColor(ggggc, facialHairColors1); break;
							case 2: readXmlSub_HairColor(ggggc, facialHairColors2); break;
							case 3: readXmlSub_HairColor(ggggc, facialHairColors3); break;
							}
							i++;
						}
					}
				}
			}
			
			grandchild = XMLReader.getFirstChildElementWithTag(child, "Body");
			if(grandchild != null) {
				aval = grandchild.getAttribute(XMLKEY_BODYHAIRUSESHAIRCOLOR);
				if(aval != null) {
					boolean b = Boolean.parseBoolean(aval);
					bodyHairUsesHairColor = b?1:0;
				}
				
				Element ggc = XMLReader.getFirstChildElementWithTag(grandchild, "HairColor");
				readXmlSub_HairColor(ggc, bodyHairColor);
				
				ggc = XMLReader.getFirstChildElementWithTag(grandchild, "GeneticStyleKeys");
				if(ggc != null) {
					int i = 0;
					List<Element> gggcList = XMLReader.getChildElementsWithTag(ggc, "StyleKey");
					for(Element ggggc : gggcList) {
						aval = ggggc.getAttribute("Value");
						int ival = -1;
						if(aval != null) ival = StringUtils.parseSignedInt(aval);
						
						switch(i) {
						case 0: mGeneticBodyhairStyleKeys0 = ival; break;
						case 1: mGeneticBodyhairStyleKeys1 = ival; break;
						case 2: mGeneticBodyhairStyleKeys2 = ival; break;
						case 3: mGeneticBodyhairStyleKeys3 = ival; break;
						case 4: mGeneticBodyhairStyleKeys4 = ival; break;
						case 5: mGeneticBodyhairStyleKeys5 = ival; break;
						case 6: mGeneticBodyhairStyleKeys6 = ival; break;
						case 7: mGeneticBodyhairStyleKeys7 = ival; break;
						}
						i++;
					}
				}
			}
		}
		
		child = XMLReader.getFirstChildElementWithTag(xml_element, "Shape");
		if(child != null) {
			
			aval = child.getAttribute(XMLKEY_MFITNESSSHAPEDELTA);
			if(aval != null) mFitnessShapeDelta = (float)Double.parseDouble(aval);
			aval = child.getAttribute(XMLKEY_MWEIGHTSHAPEDELTA);
			if(aval != null) mWeightShapeDelta = (float)Double.parseDouble(aval);
			aval = child.getAttribute(XMLKEY_MSHAPEDELTAMULTIPLIER);
			if(aval != null) mShapeDeltaMultiplier = (float)Double.parseDouble(aval);
			aval = child.getAttribute(XMLKEY_MSECONDARYNORMALMAPWEIGHTS0);
			if(aval != null) mSecondaryNormalMapWeights0 = (float)Double.parseDouble(aval);
			aval = child.getAttribute(XMLKEY_MSECONDARYNORMALMAPWEIGHTS1);
			if(aval != null) mSecondaryNormalMapWeights1 = (float)Double.parseDouble(aval);
			
			Element grandchild = null;
			grandchild = XMLReader.getFirstChildElementWithTagAndAttribute(child, "BodyShape", "VarName", XMLKEY_MINITIALSHAPE);
			if(grandchild != null) mInitialShape = BodyShape.readXMLNode(grandchild);
			grandchild = XMLReader.getFirstChildElementWithTagAndAttribute(child, "BodyShape", "VarName", XMLKEY_MCURRENTSHAPE);
			if(grandchild != null) mCurrentShape = BodyShape.readXMLNode(grandchild);
			grandchild = XMLReader.getFirstChildElementWithTagAndAttribute(child, "SurgeryBlends", "VarName", XMLKEY_SURGERYBLENDS);
			if(grandchild != null) surgeryBlends = SurgeryBlends.readXMLNode(grandchild);
		}
		
		child = XMLReader.getFirstChildElementWithTagAndAttribute(xml_element, "HealthManager", "VarName", XMLKEY_HEALTHMANAGER);
		if(child != null) healthManager = HealthManager.readXMLNode(child);
	}
	
	private void readXml_Style(Element descRoot) {
		Element xml_element = XMLReader.getFirstChildElementWithTag(descRoot, "Style");
		if(xml_element == null) return;
		
		String aval = null;
		boolean b = false;
		aval = xml_element.getAttribute(XMLKEY_PROPAGATEHAIRSTYLE);
		if(aval != null) b = Boolean.parseBoolean(aval);
		propagateHairStyle = b?1:0;
		aval = xml_element.getAttribute(XMLKEY_MDEFAULTOUTFITKEY);
		if(aval != null) mDefaultOutfitKey = StringUtils.parseSignedInt(aval);

		Element child = XMLReader.getFirstChildElementWithTagAndAttribute(xml_element, "OutfitCategoryMap", "VarName", XMLKEY_MOUTFITS);
		if(child != null) mOutfits = OutfitCategoryMap.readXMLNode(child);
		child = XMLReader.getFirstChildElementWithTagAndAttribute(xml_element, "SpecialOutfitIndices", "VarName", XMLKEY_MSPECIALOUTFITINDICES);
		if(child != null) mSpecialOutfitIndices = SpecialOutfitIndices.readXMLNode(child);		
	}
	
	private void readXml_Death(Element descRoot) {
		Element xml_element = XMLReader.getFirstChildElementWithTag(descRoot, "Death");
		if(xml_element == null) return;
		
		String aval = null;
		aval = xml_element.getAttribute(XMLKEY_MDEATHSTYLE);
		if(aval != null) mDeathStyle = DeathType.valueFromString(aval);
		aval = xml_element.getAttribute(XMLKEY_ISGHOST);
		if(aval != null) isGhost = Boolean.parseBoolean(aval);
	}
	
	private void readXml_LifetimeHappiness(Element descRoot) {
		Element xml_element = XMLReader.getFirstChildElementWithTag(descRoot, "LifetimeHappiness");
		if(xml_element == null) return;
		
		String aval = null;
		aval = xml_element.getAttribute(XMLKEY_MLIFETIMEHAPPINESS);
		if(aval != null) mLifetimeHappiness = (float)Double.parseDouble(aval);
		aval = xml_element.getAttribute(XMLKEY_MSPENDABLEHAPPINESS);
		if(aval != null) mSpendableHappiness = (float)Double.parseDouble(aval);
		aval = xml_element.getAttribute(XMLKEY_LIFETIMEWISH);
		if(aval != null) lifetimeWish = StringUtils.parseUnsignedInt(aval);
		aval = xml_element.getAttribute(XMLKEY_HASCOMPLETEDLIFETIMEWISH);
		if(aval != null) hasCompletedLifetimeWish = Boolean.parseBoolean(aval);
		
		Element child = XMLReader.getFirstChildElementWithTagAndAttribute(xml_element, "DnPExportData", "VarName", XMLKEY_DNPEXPORTDATA);
		if(child != null) dnPExportData = DnPExportData.readXMLNode(child);
	}
	
	private void readXml_Favorites(Element descRoot) {
		Element xml_element = XMLReader.getFirstChildElementWithTag(descRoot, "Favorites");
		if(xml_element == null) return;
		
		String aval = null;
		aval = xml_element.getAttribute(XMLKEY_MFAVOURITEMUSICTYPE);
		if(aval != null) mFavouriteMusicType = FavoriteMusicType.valueFromString(aval);
		aval = xml_element.getAttribute(XMLKEY_MFAVOURITEFOODTYPE);
		if(aval != null) mFavouriteFoodType = FavoriteFoodType.valueFromString(aval);
		aval = xml_element.getAttribute(XMLKEY_MFAVOURITECOLORARGB);
		if(aval != null) mFavouriteColorARGB = StringUtils.parseUnsignedInt(aval);
		aval = xml_element.getAttribute(XMLKEY_MPREFERREDVEHICLEGUID);
		if(aval != null) mPreferredVehicleGuid = StringUtils.parseUnsignedInt(aval);
	}
	
	private void readXml_Academics(Element descRoot) {
		Element xml_element = XMLReader.getFirstChildElementWithTag(descRoot, "Academics");
		if(xml_element == null) return;
		
		String aval = null;
		aval = xml_element.getAttribute(XMLKEY_ALMAMATER);
		if(aval != null) almaMater = AlmaMater.valueFromString(aval);
		aval = xml_element.getAttribute(XMLKEY_MALMAMATERNAME);
		if(aval != null) mAlmaMaterName = aval;
		aval = xml_element.getAttribute(XMLKEY_GRADUATIONTYPE);
		if(aval != null) graduationType = GraduationType.valueFromString(aval);
		
		Element child = XMLReader.getFirstChildElementWithTagAndAttribute(xml_element, "AcademicDegreeManager", "VarName", XMLKEY_DEGREEMANAGER);
		if(child != null) degreeManager = AcademicDegreeManager.readXMLNode(child);
	}
	
	private void readXml_Career(Element descRoot) {
		Element xml_element = XMLReader.getFirstChildElementWithTag(descRoot, "Career");
		if(xml_element == null) return;
		
		String aval = null;
		aval = xml_element.getAttribute(XMLKEY_SERVICEHISTORY);
		if(aval != null) serviceHistory = ServiceType.valueFromString(aval);
		aval = xml_element.getAttribute(XMLKEY_CANBEKILLEDONJOB);
		if(aval != null) canBeKilledOnJob = Boolean.parseBoolean(aval);
		
		Element child = XMLReader.getFirstChildElementWithTagAndAttribute(xml_element, "CareerManager", "VarName", XMLKEY_CAREERMANAGER);
		if(child != null) careerManager = CareerManager.readXMLNode(child);
	}
	
	private void readXml_Family(Element descRoot) {
		Element xml_element = XMLReader.getFirstChildElementWithTag(descRoot, "Family");
		if(xml_element == null) return;
		
		String aval = null;
		aval = xml_element.getAttribute(XMLKEY_ISPREGNANT);
		if(aval != null) isPregnant = Boolean.parseBoolean(aval);
		aval = xml_element.getAttribute(XMLKEY_ISVISUALLYPREGNANT);
		if(aval != null) isVisuallyPregnant = Boolean.parseBoolean(aval);
		
		Element child = XMLReader.getFirstChildElementWithTagAndAttribute(xml_element, "Genealogy", "VarName", XMLKEY_MGENEALOGY);
		if(child != null) mGenealogy = Genealogy.readXMLNode(child);
		child = XMLReader.getFirstChildElementWithTagAndAttribute(xml_element, "Pregnancy", "VarName", XMLKEY_PREGNANCY);
		if(child != null) pregnancy = Pregnancy.readXMLNode(child);
	}
	
	private void readXml_Skills(Element descRoot) {
		Element xml_element = XMLReader.getFirstChildElementWithTag(descRoot, "Skills");
		if(xml_element == null) return;
		
		String aval = null;
		aval = xml_element.getAttribute(XMLKEY_KNOWNSNOWMANTYPES);
		if(aval != null) knownSnowmanTypes = SnowmanFlagType.valueFromString(aval);
		
		Element child = XMLReader.getFirstChildElementWithTagAndAttribute(xml_element, "SkillManager", "VarName", XMLKEY_SKILLMANAGER);
		if(child != null) skillManager = SkillManager.readXMLNode(child);
		child = XMLReader.getFirstChildElementWithTagAndAttribute(xml_element, "SingingInfo", "VarName", XMLKEY_SINGING);
		if(child != null) singing = SingingInfo.readXMLNode(child);
		
		child = XMLReader.getFirstChildElementWithTag(xml_element, "ReadBooks");
		if(child != null) {
			List<Element> gclist = XMLReader.getChildElementsWithTagAndAttribute(child, "ReadBookInstance", "VarName", XMLKEY_READBOOKDATALIST);
			int len = gclist.size();
			if(len > 0) readBookDataList.ensureCapacity(len);
			for(Element gc : gclist) {
				ReadBookInstance readBook = ReadBookInstance.readXMLNode(gc);
				if(readBook != null) readBookDataList.add(readBook);
			}
			readBookCount = readBookDataList.size();
		}
	}
	
	private void readXml_Traits(Element descRoot) {
		Element xml_element = XMLReader.getFirstChildElementWithTag(descRoot, "Traits");
		if(xml_element == null) return;
		
		String aval = null;

		Element child = XMLReader.getFirstChildElementWithTagAndAttribute(xml_element, "TraitManager", "VarName", XMLKEY_TRAITMANAGER);
		if(child != null) traitManager = TraitManager.readXMLNode(child);
		child = XMLReader.getFirstChildElementWithTagAndAttribute(xml_element, "PetManager", "VarName", XMLKEY_PETMANAGER);
		if(child != null) petManager = PetManager.readXMLNode(child);
		child = XMLReader.getFirstChildElementWithTagAndAttribute(xml_element, "TraitChipManager", "VarName", XMLKEY_MTRAITCHIPMANAGER);
		if(child != null) mTraitChipManager = TraitChipManager.readXMLNode(child);
		
		child = XMLReader.getFirstChildElementWithTag(xml_element, "TraitList");
		if(child != null) {
			List<Element> gclist = XMLReader.getChildElementsWithTag(child, "Trait");
			int len = gclist.size();
			if(len > 0) {
				traitGuids = new long[len];
				int i = 0;
				for(Element gc : gclist) {
					aval = gc.getAttribute("EnumString");
					if(aval != null) {
						traitGuids[i] = TraitNames.valueFromString(aval);
					}
					i++;
				}
			}
			else traitGuids = null;
			traitCount = len;
		}
	}
	
	private void readXml_Occult(Element descRoot) {
		Element xml_element = XMLReader.getFirstChildElementWithTag(descRoot, "Occult");
		if(xml_element == null) return;
		
		String aval = null;
		aval = xml_element.getAttribute(XMLKEY_OCCULTTYPE);
		if(aval != null) occultType = OccultTypes.valueFromString(aval);
		aval = xml_element.getAttribute(XMLKEY_SSUPERNATURALVERSIONNUMBER);
		if(aval != null) sSupernaturalVersionNumber = StringUtils.parseUnsignedInt(aval);
		aval = xml_element.getAttribute(XMLKEY_MOCCULTTYPE);
		if(aval != null) mOccultType = OccultTypes.valueFromString(aval);
		
		Element child = XMLReader.getFirstChildElementWithTagAndAttribute(xml_element, "OccultManager", "VarName", XMLKEY_OCCULTMANAGER);
		if(child != null) occultManager = OccultManager.readXMLNode(child);
	}
	
	private void readXml_WorldTravel(Element descRoot) {
		Element xml_element = XMLReader.getFirstChildElementWithTag(descRoot, "WorldTravel");
		if(xml_element == null) return;

		Element child = XMLReader.getFirstChildElementWithTagAndAttribute(xml_element, "RelicStatTracking", "VarName", XMLKEY_RELICSTATS);
		if(child != null) relicStats = RelicStatTracking.readXMLNode(child);
		child = XMLReader.getFirstChildElementWithTagAndAttribute(xml_element, "TombStatTracking", "VarName", XMLKEY_TOMBSTATS);
		if(child != null) tombStats = TombStatTracking.readXMLNode(child);
		child = XMLReader.getFirstChildElementWithTagAndAttribute(xml_element, "VisaManager", "VarName", XMLKEY_VISAMANAGER);
		if(child != null) visaManager = VisaManager.readXMLNode(child);
	}
	
	private void readXml_Social(Element descRoot) {
		Element xml_element = XMLReader.getFirstChildElementWithTag(descRoot, "Social");
		if(xml_element == null) return;

		Element child = XMLReader.getFirstChildElementWithTagAndAttribute(xml_element, "CelebrityManager", "VarName", XMLKEY_CELEBRITYMANAGER);
		if(child != null) celebrityManager = CelebrityManager.readXMLNode(child);
		child = XMLReader.getFirstChildElementWithTagAndAttribute(xml_element, "ReputationStatistics", "VarName", XMLKEY_MREPUTATION);
		if(child != null) mReputation = ReputationStatistics.readXMLNode(child);
		child = XMLReader.getFirstChildElementWithTagAndAttribute(xml_element, "SocialExpTraveling", "VarName", XMLKEY_SOCIALEXPTRAVELING);
		if(child != null) socialExpTraveling = SocialExpTraveling.readXMLNode(child);
	}
	
	private void readXml_LifeEvents(Element descRoot) {
		Element xml_element = XMLReader.getFirstChildElementWithTag(descRoot, "LifeEvents");
		if(xml_element == null) return;

		Element child = XMLReader.getFirstChildElementWithTagAndAttribute(xml_element, "LifeEventManager", "VarName", XMLKEY_LIFEEVENTMANAGER);
		if(child != null) lifeEventManager = LifeEventManager.readXMLNode(child);
		child = XMLReader.getFirstChildElementWithTagAndAttribute(xml_element, "MidlifeCrisisManager", "VarName", XMLKEY_MIDLIFECRISISMANAGER);
		if(child != null) midlifeCrisisManager = MidlifeCrisisManager.readXMLNode(child);
	}
	
	private void readXml_Opportunities(Element descRoot) {
		Element xml_element = XMLReader.getFirstChildElementWithTag(descRoot, "Opportunities");
		if(xml_element == null) return;
		
		String aval = null;
		aval = xml_element.getAttribute(XMLKEY_NEEDSOPPORTUNITYIMPORT);
		if(aval != null) needsOpportunityImport = Boolean.parseBoolean(aval);
		
		Element child = XMLReader.getFirstChildElementWithTagAndAttribute(xml_element, "OpportunityHistory", "VarName", XMLKEY_OPPORTUNITYHISTORY);
		if(child != null) opportunityHistory = OpportunityHistory.readXMLNode(child);
	}
	
	private void readXml_Mood(Element descRoot) {
		Element xml_element = XMLReader.getFirstChildElementWithTag(descRoot, "Mood");
		if(xml_element == null) return;
		Element child = XMLReader.getFirstChildElementWithTagAndAttribute(xml_element, "TravelBuffList", "VarName", XMLKEY_TRAVELBUFFS);
		if(child != null) travelBuffs = TravelBuffList.readXMLNode(child);
	}
	
	protected boolean readXMLNode_internal(Element xml_element) {
		if(xml_element == null) return false;
		String nn = xml_element.getNodeName();
		if(nn == null) return false;
		if(!nn.equals(xmlNodeName)) return false;
		
		String aval = null;
		aval = xml_element.getAttribute(XMLKEY_SIMDESCRIPTIONID);
		if(aval != null) simDescriptionId = StringUtils.parseUnsignedLong(aval);
		aval = xml_element.getAttribute(XMLKEY_ISNEVERSELECTABLE);
		if(aval != null) isNeverSelectable = Boolean.parseBoolean(aval);
		aval = xml_element.getAttribute(XMLKEY_MARRYABLE);
		if(aval != null) marryable = Boolean.parseBoolean(aval);
		aval = xml_element.getAttribute(XMLKEY_CONTACTABLE);
		if(aval != null) contactable = Boolean.parseBoolean(aval);

		readXml_Basics(xml_element);
		readXml_Aging(xml_element);
		readXml_Physical(xml_element);
		readXml_Style(xml_element);
		readXml_Death(xml_element);
		readXml_LifetimeHappiness(xml_element);
		readXml_Favorites(xml_element);
		readXml_Academics(xml_element);
		readXml_Career(xml_element);
		readXml_Family(xml_element);
		readXml_Skills(xml_element);
		readXml_Traits(xml_element);
		readXml_Occult(xml_element);
		readXml_WorldTravel(xml_element);
		readXml_Social(xml_element);
		readXml_LifeEvents(xml_element);
		readXml_Opportunities(xml_element);
		readXml_Mood(xml_element);
		
		return true;
	}
	
	protected boolean readPropertyStream_internal(MaxisPropertyStream stream) {
		if(stream == null) return false;
		
		simDescriptionId = stream.getFieldAsLong(PSID_SIMDESCRIPTIONID, false);
		mSimFlags = stream.getFieldAsInt(PSID_MSIMFLAGS, false);
		agingYearsSinceLastAgeTransition = stream.getFieldAsFloat(PSID_AGINGYEARSSINCELASTAGETRANSITION);
		userDaysInCurrentAge = stream.getFieldAsInt(PSID_USERDAYSINCURRENTAGE, true);
		mSkinToneKey = stream.getFieldAsInt(PSID_MSKINTONEKEY, true);
		mSkinToneIndex = stream.getFieldAsFloat(PSID_MSKINTONEINDEX);
		mSecondaryNormalMapWeights0 = stream.getFieldAsFloat(PSID_MSECONDARYNORMALMAPWEIGHTS0);
		mSecondaryNormalMapWeights1 = stream.getFieldAsFloat(PSID_MSECONDARYNORMALMAPWEIGHTS1);
		mDefaultOutfitKey = stream.getFieldAsInt(PSID_MDEFAULTOUTFITKEY, true);
		hairColors0 = stream.getFieldAsIntArray(PSID_HAIRCOLORS0, false);
		hairColors1 = stream.getFieldAsIntArray(PSID_HAIRCOLORS1, false);
		hairColors2 = stream.getFieldAsIntArray(PSID_HAIRCOLORS2, false);
		hairColors3 = stream.getFieldAsIntArray(PSID_HAIRCOLORS3, false);
		eyebrowColor = stream.getFieldAsIntArray(PSID_EYEBROWCOLOR, false);
		bodyHairColor = stream.getFieldAsIntArray(PSID_BODYHAIRCOLOR, false);
		facialHairColors0 = stream.getFieldAsIntArray(PSID_FACIALHAIRCOLORS0, false);
		facialHairColors1 = stream.getFieldAsIntArray(PSID_FACIALHAIRCOLORS1, false);
		facialHairColors2 = stream.getFieldAsIntArray(PSID_FACIALHAIRCOLORS2, false);
		facialHairColors3 = stream.getFieldAsIntArray(PSID_FACIALHAIRCOLORS3, false);
		beardUsesHairColor = stream.getFieldAsInt(PSID_BEARDUSESHAIRCOLOR, false);
		eyebrowsUseHairColor = stream.getFieldAsInt(PSID_EYEBROWSUSEHAIRCOLOR, false);
		bodyHairUsesHairColor = stream.getFieldAsInt(PSID_BODYHAIRUSESHAIRCOLOR, false);
		propagateHairStyle = stream.getFieldAsInt(PSID_PROPAGATEHAIRSTYLE, false);
		mHousehold = stream.getFieldAsLong(PSID_MHOUSEHOLD, false);
		mFirstName = stream.getFieldAsString(PSID_MFIRSTNAME);
		mLastName = stream.getFieldAsString(PSID_MLASTNAME);
		mDeathStyle = stream.getFieldAsInt(PSID_MDEATHSTYLE, false);
		isNeverSelectable = stream.getFieldAsBool(PSID_ISNEVERSELECTABLE);
		agingEnabled = stream.getFieldAsBool(PSID_AGINGENABLED);
		mLifetimeHappiness = stream.getFieldAsFloat(PSID_MLIFETIMEHAPPINESS);
		mSpendableHappiness = stream.getFieldAsFloat(PSID_MSPENDABLEHAPPINESS);
		mFavouriteMusicType = stream.getFieldAsInt(PSID_MFAVOURITEMUSICTYPE, false);
		mFavouriteFoodType = stream.getFieldAsInt(PSID_MFAVOURITEFOODTYPE, false);
		mFavouriteColorARGB = stream.getFieldAsInt(PSID_MFAVOURITECOLORARGB, false);
		mBio = stream.getFieldAsString(PSID_MBIO);
		mZodiacSign = stream.getFieldAsInt(PSID_MZODIACSIGN, false);
		almaMater = stream.getFieldAsInt(PSID_ALMAMATER, false);
		mAlmaMaterName = stream.getFieldAsString(PSID_MALMAMATERNAME);
		graduationType = stream.getFieldAsInt(PSID_GRADUATIONTYPE, false);
		serviceHistory = stream.getFieldAsLong(PSID_SERVICEHISTORY, false);
		marryable = stream.getFieldAsBool(PSID_MARRYABLE);
		canBeKilledOnJob = stream.getFieldAsBool(PSID_CANBEKILLEDONJOB);
		isGhost = stream.getFieldAsBool(PSID_ISGHOST);
		contactable = stream.getFieldAsBool(PSID_CONTACTABLE);
		isPregnant = stream.getFieldAsBool(PSID_ISPREGNANT);
		isVisuallyPregnant = stream.getFieldAsBool(PSID_ISVISUALLYPREGNANT);
		alienDNAPercentage = stream.getFieldAsFloat(PSID_ALIENDNAPERCENTAGE);
		mInitialShape = BodyShape.readPropertyStream(stream.getChildStream(PSID_MINITIALSHAPE));
		mCurrentShape = BodyShape.readPropertyStream(stream.getChildStream(PSID_MCURRENTSHAPE));
		mFitnessShapeDelta = stream.getFieldAsFloat(PSID_MFITNESSSHAPEDELTA);
		mWeightShapeDelta = stream.getFieldAsFloat(PSID_MWEIGHTSHAPEDELTA);
		mShapeDeltaMultiplier = stream.getFieldAsFloat(PSID_MSHAPEDELTAMULTIPLIER);
		mVoiceVariation = stream.getFieldAsInt(PSID_MVOICEVARIATION, false);
		mVoicePitchModifier = stream.getFieldAsFloat(PSID_MVOICEPITCHMODIFIER);
		mGeneticHairstyleKey = stream.getFieldAsInt(PSID_MGENETICHAIRSTYLEKEY, true);
		mGeneticBodyhairStyleKeys0 = stream.getFieldAsInt(PSID_MGENETICBODYHAIRSTYLEKEYS0, true);
		mGeneticBodyhairStyleKeys1 = stream.getFieldAsInt(PSID_MGENETICBODYHAIRSTYLEKEYS1, true);
		mGeneticBodyhairStyleKeys2 = stream.getFieldAsInt(PSID_MGENETICBODYHAIRSTYLEKEYS2, true);
		mGeneticBodyhairStyleKeys3 = stream.getFieldAsInt(PSID_MGENETICBODYHAIRSTYLEKEYS3, true);
		mGeneticBodyhairStyleKeys4 = stream.getFieldAsInt(PSID_MGENETICBODYHAIRSTYLEKEYS4, true);
		mGeneticBodyhairStyleKeys5 = stream.getFieldAsInt(PSID_MGENETICBODYHAIRSTYLEKEYS5, true);
		mGeneticBodyhairStyleKeys6 = stream.getFieldAsInt(PSID_MGENETICBODYHAIRSTYLEKEYS6, true);
		mGeneticBodyhairStyleKeys7 = stream.getFieldAsInt(PSID_MGENETICBODYHAIRSTYLEKEYS7, true);
		mHomeWorld = stream.getFieldAsInt(PSID_MHOMEWORLD, true);
		mOutfits = OutfitCategoryMap.readPropertyStream(stream.getChildStream(PSID_MOUTFITS));
		
		//I wonder if this is a bug.
		//The ExportContent function creates a new child, but then writes mSpecialOutfitIndices to the
		//	parent stream. Then closes the child.
		//mSpecialOutfitIndices = SpecialOutfitIndices.readPropertyStream(stream.getChildStream(PSID_MSPECIALOUTFITINDICES));
		mSpecialOutfitIndices = SpecialOutfitIndices.readPropertyStream(stream); 
		
		traitCount = stream.getFieldAsInt(PSID_TRAITCOUNT, false);
		traitGuids = stream.getFieldAsLongArray(PSID_TRAITGUIDS, false);
		traitManager = TraitManager.readPropertyStream(stream.getChildStream(PSID_TRAITMANAGER));
		mGenealogy = Genealogy.readPropertyStream(stream.getChildStream(PSID_MGENEALOGY));
		lifetimeWish = stream.getFieldAsInt(PSID_LIFETIMEWISH, false);
		hasCompletedLifetimeWish = stream.getFieldAsBool(PSID_HASCOMPLETEDLIFETIMEWISH);
		
		//mSupernaturalData
		occultType = stream.getFieldAsInt(PSID_OCCULTTYPE, false);
		sSupernaturalVersionNumber = stream.getFieldAsInt(PSID_SSUPERNATURALVERSIONNUMBER, false);
		mOccultType = stream.getFieldAsInt(PSID_MOCCULTTYPE, false);
		
		skillManager = SkillManager.readPropertyStream(stream.getChildStream(PSID_SKILLMANAGER));
		careerManager = CareerManager.readPropertyStream(stream.getChildStream(PSID_CAREERMANAGER));
		visaManager = VisaManager.readPropertyStream(stream.getChildStream(PSID_VISAMANAGER));
		celebrityManager = CelebrityManager.readPropertyStream(stream.getChildStream(PSID_CELEBRITYMANAGER));
		lifeEventManager = LifeEventManager.readPropertyStream(stream.getChildStream(PSID_LIFEEVENTMANAGER));
		occultManager = OccultManager.readPropertyStream(stream.getChildStream(PSID_OCCULTMANAGER));
		healthManager = HealthManager.readPropertyStream(stream.getChildStream(PSID_HEALTHMANAGER));
		mReputation = ReputationStatistics.readPropertyStream(stream.getChildStream(PSID_MREPUTATION));
		midlifeCrisisManager = MidlifeCrisisManager.readPropertyStream(stream.getChildStream(PSID_MIDLIFECRISISMANAGER));
		petManager = PetManager.readPropertyStream(stream.getChildStream(PSID_PETMANAGER));
		
		readBookCount = stream.getFieldAsInt(PSID_READBOOKCOUNT, true);
		readBookDataList.ensureCapacity(readBookCount);
		for(int i = 0; i < readBookCount; i++){
			ReadBookInstance readBookData = new ReadBookInstance();
			readBookData.psidKey = PSID_READBOOKDATALIST + i;
			readBookData.psidData = PSID_READBOOKDATABASE + i;
			readBookData.readPropertyStream_internal(stream);
			readBookDataList.add(readBookData);
		}
		
		pregnancy = Pregnancy.readPropertyStream(stream.getChildStream(PSID_PREGNANCY));
		opportunityHistory = OpportunityHistory.readPropertyStream(stream.getChildStream(PSID_OPPORTUNITYHISTORY));
		needsOpportunityImport = stream.getFieldAsBool(PSID_NEEDSOPPORTUNITYIMPORT);
		dnPExportData = DnPExportData.readPropertyStream(stream.getChildStream(PSID_DNPEXPORTDATA));
		relicStats = RelicStatTracking.readPropertyStream(stream.getChildStream(PSID_RELICSTATS));
		tombStats = TombStatTracking.readPropertyStream(stream.getChildStream(PSID_TOMBSTATS));
		
		travelBuffs = TravelBuffList.readPropertyStream(stream.getChildStream(PSID_TRAVELBUFFS));
		
		mPreferredVehicleGuid = stream.getFieldAsInt(PSID_MPREFERREDVEHICLEGUID, true);
		singing = SingingInfo.readPropertyStream(stream.getChildStream(PSID_SINGING));
		socialExpTraveling = SocialExpTraveling.readPropertyStream(stream);
		knownSnowmanTypes = stream.getFieldAsByte(PSID_KNOWNSNOWMANTYPES);
		surgeryBlends = SurgeryBlends.readPropertyStream(stream);
		degreeManager = AcademicDegreeManager.readPropertyStream(stream.getChildStream(PSID_DEGREEMANAGER));
		mTraitChipManager = TraitChipManager.readPropertyStream(stream.getChildStream(PSID_MTRAITCHIPMANAGER));

		return true;
	}
	
	public static SimDescription readBinary(BufferReference dat) {
		if(dat == null) return null;
		SimDescription str = new SimDescription();
		if(!str.readBinary_internal(dat)) return null;
		return str;
	}
	
	public static SimDescription readXMLNode(Element xml_element) {
		if(xml_element == null) return null;
		SimDescription str = new SimDescription();
		if(!str.readXMLNode_internal(xml_element)) return null;
		return str;
	}
	
	public static SimDescription readPropertyStream(BufferReference dat, boolean byteOrder, int verFieldSize) {
		if(dat == null) return null;
		MaxisPropertyStream stream = MaxisPropertyStream.openForRead(dat, byteOrder, verFieldSize);
		return readPropertyStream(stream);
	}
	
	public static SimDescription readPropertyStream(MaxisPropertyStream stream) {
		if(stream == null) return null;
		SimDescription str = new SimDescription();
		if(!str.readPropertyStream_internal(stream));
		return str;
	}
	
	/*----- Write -----*/
	
	public int getBinarySize() {
		int size = baseSize;
		size += (hairColors0.length * 4);
		size += (hairColors1.length * 4);
		size += (hairColors2.length * 4);
		size += (hairColors3.length * 4);
		size += (eyebrowColor.length * 4);
		size += (bodyHairColor.length * 4);
		size += (facialHairColors0.length * 4);
		size += (facialHairColors1.length * 4);
		size += (facialHairColors2.length * 4);
		size += (facialHairColors3.length * 4);
		size += (mFirstName.length() << 1);
		size += (mLastName.length() << 1);
		size += (mBio.length() << 1);
		size += (mAlmaMaterName.length() << 1);
		size += mInitialShape.getBinarySize();
		size += mCurrentShape.getBinarySize();
		size += mOutfits.getBinarySize();
		size += mSpecialOutfitIndices.getBinarySize();
		if(traitGuids != null){
			size += (traitGuids.length * 8);
		}
		size += traitManager.getBinarySize();
		size += mGenealogy.getBinarySize();
		size += skillManager.getBinarySize();
		size += careerManager.getBinarySize();
		size += visaManager.getBinarySize();
		size += celebrityManager.getBinarySize();
		size += lifeEventManager.getBinarySize();
		size += occultManager.getBinarySize();
		 if(healthManager != null) size += healthManager.getBinarySize();
		 if(mReputation != null) size += mReputation.getBinarySize();
		 if(midlifeCrisisManager != null) size += midlifeCrisisManager.getBinarySize();
		 if(petManager != null) size += petManager.getBinarySize();
		for(ReadBookInstance readBookDataList : readBookDataList){
			size += readBookDataList.getBinarySize();
		}
		 if(pregnancy != null) size += pregnancy.getBinarySize();
		 if(opportunityHistory != null) size += opportunityHistory.getBinarySize();
		 if(dnPExportData != null) size += dnPExportData.getBinarySize();
		 if(relicStats != null) size += relicStats.getBinarySize();
		 if(tombStats != null) size += tombStats.getBinarySize();
		 if(travelBuffs != null) size += travelBuffs.getBinarySize();
		 if(singing != null) size += singing.getBinarySize();
		 if(socialExpTraveling != null) size += socialExpTraveling.getBinarySize();
		size += surgeryBlends.getBinarySize();
		 if(degreeManager != null) size += degreeManager.getBinarySize();
		 if(mTraitChipManager != null) size += mTraitChipManager.getBinarySize();
		return size;
	}
	
	public FileBuffer writeBinary(boolean byteOrder) {
		FileBuffer buff = new FileBuffer(getBinarySize(), byteOrder);
		writeBinaryTo(buff);
		return buff;
	}
	
	public int writeBinaryTo(FileBuffer target) {
		if(target == null) return 0;
		long stPos = target.getFileSize();
		
		traitCount = traitGuids.length;
		readBookCount = readBookDataList.size();
		target.addToFile(simDescriptionId);
		target.addToFile(mSimFlags);
		target.addToFile(Float.floatToRawIntBits(agingYearsSinceLastAgeTransition));
		target.addToFile(userDaysInCurrentAge);
		target.addToFile(mSkinToneKey);
		target.addToFile(Float.floatToRawIntBits(mSkinToneIndex));
		target.addToFile(Float.floatToRawIntBits(mSecondaryNormalMapWeights0));
		target.addToFile(Float.floatToRawIntBits(mSecondaryNormalMapWeights1));
		target.addToFile(mDefaultOutfitKey);
		for(int i = 0; i < 3; i++){
			target.addToFile(hairColors0[i]);
		}
		for(int i = 0; i < 3; i++){
			target.addToFile(hairColors1[i]);
		}
		for(int i = 0; i < 3; i++){
			target.addToFile(hairColors2[i]);
		}
		for(int i = 0; i < 3; i++){
			target.addToFile(hairColors3[i]);
		}
		for(int i = 0; i < 3; i++){
			target.addToFile(eyebrowColor[i]);
		}
		for(int i = 0; i < 3; i++){
			target.addToFile(bodyHairColor[i]);
		}
		for(int i = 0; i < 3; i++){
			target.addToFile(facialHairColors0[i]);
		}
		for(int i = 0; i < 3; i++){
			target.addToFile(facialHairColors1[i]);
		}
		for(int i = 0; i < 3; i++){
			target.addToFile(facialHairColors2[i]);
		}
		for(int i = 0; i < 3; i++){
			target.addToFile(facialHairColors3[i]);
		}
		target.addToFile(beardUsesHairColor);
		target.addToFile(eyebrowsUseHairColor);
		target.addToFile(bodyHairUsesHairColor);
		target.addToFile(propagateHairStyle);
		target.addToFile(mHousehold);
		MaxisTypes.serializeMaxisStringTo( mFirstName, target);
		MaxisTypes.serializeMaxisStringTo( mLastName, target);
		target.addToFile(mDeathStyle);
		MaxisTypes.writeBinaryBool(target, isNeverSelectable);
		MaxisTypes.writeBinaryBool(target, agingEnabled);
		target.addToFile(Float.floatToRawIntBits(mLifetimeHappiness));
		target.addToFile(Float.floatToRawIntBits(mSpendableHappiness));
		target.addToFile(mFavouriteMusicType);
		target.addToFile(mFavouriteFoodType);
		target.addToFile(mFavouriteColorARGB);
		MaxisTypes.serializeMaxisStringTo( mBio, target);
		target.addToFile(mZodiacSign);
		target.addToFile(almaMater);
		MaxisTypes.serializeMaxisStringTo( mAlmaMaterName, target);
		target.addToFile(graduationType);
		target.addToFile(serviceHistory);
		MaxisTypes.writeBinaryBool(target, marryable);
		MaxisTypes.writeBinaryBool(target, canBeKilledOnJob);
		MaxisTypes.writeBinaryBool(target, isGhost);
		MaxisTypes.writeBinaryBool(target, contactable);
		MaxisTypes.writeBinaryBool(target, isPregnant);
		MaxisTypes.writeBinaryBool(target, isVisuallyPregnant);
		target.addToFile(Float.floatToRawIntBits(alienDNAPercentage));
		mInitialShape.writeBinaryTo(target);
		mCurrentShape.writeBinaryTo(target);
		target.addToFile(Float.floatToRawIntBits(mFitnessShapeDelta));
		target.addToFile(Float.floatToRawIntBits(mWeightShapeDelta));
		target.addToFile(Float.floatToRawIntBits(mShapeDeltaMultiplier));
		target.addToFile(mVoiceVariation);
		target.addToFile(Float.floatToRawIntBits(mVoicePitchModifier));
		target.addToFile(mGeneticHairstyleKey);
		target.addToFile(mGeneticBodyhairStyleKeys0);
		target.addToFile(mGeneticBodyhairStyleKeys1);
		target.addToFile(mGeneticBodyhairStyleKeys2);
		target.addToFile(mGeneticBodyhairStyleKeys3);
		target.addToFile(mGeneticBodyhairStyleKeys4);
		target.addToFile(mGeneticBodyhairStyleKeys5);
		target.addToFile(mGeneticBodyhairStyleKeys6);
		target.addToFile(mGeneticBodyhairStyleKeys7);
		target.addToFile(mHomeWorld);
		mOutfits.writeBinaryTo(target);
		mSpecialOutfitIndices.writeBinaryTo(target);
		target.addToFile(traitCount);
		for(int i = 0; i < traitCount; i++){
			target.addToFile(traitGuids[i]);
		}
		traitManager.writeBinaryTo(target);
		mGenealogy.writeBinaryTo(target);
		target.addToFile(lifetimeWish);
		MaxisTypes.writeBinaryBool(target, hasCompletedLifetimeWish);
		target.addToFile(occultType);
		target.addToFile(sSupernaturalVersionNumber);
		target.addToFile(mOccultType);
		skillManager.writeBinaryTo(target);
		careerManager.writeBinaryTo(target);
		visaManager.writeBinaryTo(target);
		celebrityManager.writeBinaryTo(target);
		lifeEventManager.writeBinaryTo(target);
		occultManager.writeBinaryTo(target);
		healthManager.writeBinaryTo(target);
		mReputation.writeBinaryTo(target);
		midlifeCrisisManager.writeBinaryTo(target);
		petManager.writeBinaryTo(target);
		target.addToFile(readBookCount);
		for(ReadBookInstance readBookDataList : readBookDataList){
			readBookDataList.writeBinaryTo(target);
		}
		pregnancy.writeBinaryTo(target);
		opportunityHistory.writeBinaryTo(target);
		MaxisTypes.writeBinaryBool(target, needsOpportunityImport);
		dnPExportData.writeBinaryTo(target);
		relicStats.writeBinaryTo(target);
		tombStats.writeBinaryTo(target);
		travelBuffs.writeBinaryTo(target);
		target.addToFile(this.mPreferredVehicleGuid);
		singing.writeBinaryTo(target);
		socialExpTraveling.writeBinaryTo(target);
		target.addToFile(knownSnowmanTypes);
		surgeryBlends.writeBinaryTo(target);
		degreeManager.writeBinaryTo(target);
		mTraitChipManager.writeBinaryTo(target);

		return (int)(target.getFileSize() - stPos);
	}

	public void writeXMLNode(Writer out, String indent) throws IOException {
		writeXMLNode(out, indent, null);
	}
	
	private void writeXml_Basics(Writer out, String indent) throws IOException {
		out.write(indent + "<Biographical");
		out.write(String.format(" %s=\"%s\"", XMLKEY_MFIRSTNAME, mFirstName));
		out.write(String.format(" %s=\"%s\"", XMLKEY_MLASTNAME, mLastName));
		out.write(String.format(" %s=\"%s\"", XMLKEY_MSIMFLAGS, CASAgeGenderFlags.stringFromValue(mSimFlags)));
		out.write(String.format(" %s=\"%s\"", XMLKEY_MZODIACSIGN, Zodiac.stringFromValue(mZodiacSign)));
		out.write(String.format(" %s=\"%s\"", XMLKEY_MHOMEWORLD, WorldName.stringFromValue(mHomeWorld)));
		out.write(String.format(" %s=\"0x%016x\"", XMLKEY_MHOUSEHOLD, mHousehold));
		out.write(">\n");
		
		out.write(indent + "\t<" + XMLKEY_MBIO + ">");
		if(mBio != null) {
			out.write(String.format("\"%s\"", mBio));
		}
		else out.write("\"\"");
		out.write("</" + XMLKEY_MBIO + ">\n");
		
		out.write(indent + "</Biographical>\n");
	}
	
	private void writeXml_Aging(Writer out, String indent) throws IOException {
		out.write(indent + "<Aging");
		out.write(String.format(" %s=\"%b\"", XMLKEY_AGINGENABLED, agingEnabled));
		out.write(String.format(" %s=\"%.3f\"", XMLKEY_AGINGYEARSSINCELASTAGETRANSITION, agingYearsSinceLastAgeTransition));
		out.write(String.format(" %s=\"%d\"", XMLKEY_USERDAYSINCURRENTAGE, userDaysInCurrentAge));
		out.write("/>\n");
	}
	
	private void writeXmlSub_HairColor(Writer out, String indent, int[] clrData) throws IOException {
		out.write(indent + "<HairColor");
		out.write(String.format(" GeneticARGB=\"0x%08x\"", clrData[0]));
		out.write(String.format(" DyeARGB=\"0x%08x\"", clrData[1]));
		out.write(String.format(" UseDye=\"%b\"", (clrData[2] != 0)));
		out.write("/>\n");
	}
	
	private void writeXml_Physical(Writer out, String indent) throws IOException {
		out.write(indent + "<PhysAttributes");
		out.write(String.format(" %s=\"%s\"", XMLKEY_MVOICEVARIATION, VoiceVariationType.stringFromValue(mVoiceVariation)));
		out.write(String.format(" %s=\"%.3f\"", XMLKEY_MVOICEPITCHMODIFIER, mVoicePitchModifier));
		out.write(String.format(" %s=\"%.3f\"", XMLKEY_ALIENDNAPERCENTAGE, alienDNAPercentage));
		out.write(">\n");

		//Skin
		out.write(indent + "\t<Skin");
		out.write(String.format(" %s=\"%d\"", XMLKEY_MSKINTONEKEY, mSkinToneKey));
		out.write(String.format(" %s=\"%.3f\"", XMLKEY_MSKINTONEINDEX, mSkinToneIndex));
		out.write("/>\n");

		//Hair
		out.write(indent + "\t<Hair>\n");
		out.write(indent + "\t\t<Head");
		out.write(String.format(" %s=\"%d\"", XMLKEY_MGENETICHAIRSTYLEKEY, mGeneticHairstyleKey)); //WTF is a "genetic hairstyle" lol
		out.write(">\n");
		out.write(indent + "\t\t\t<HairColors>\n");
		writeXmlSub_HairColor(out, indent + "\t\t\t\t", hairColors0);
		writeXmlSub_HairColor(out, indent + "\t\t\t\t", hairColors1);
		writeXmlSub_HairColor(out, indent + "\t\t\t\t", hairColors2);
		writeXmlSub_HairColor(out, indent + "\t\t\t\t", hairColors3);
		out.write(indent + "\t\t\t</HairColors>\n");
		out.write(indent + "\t\t</Head>\n");
		out.write(indent + "\t\t<Face>\n");
		out.write(indent + "\t\t\t<Eyebrows");
		out.write(String.format(" %s=\"%b\">\n", XMLKEY_EYEBROWSUSEHAIRCOLOR, (eyebrowsUseHairColor != 0)));
		writeXmlSub_HairColor(out, indent + "\t\t\t\t", eyebrowColor);
		out.write(indent + "\t\t\t</Eyebrows>\n");
		out.write(indent + "\t\t\t<FacialHair");
		out.write(String.format(" %s=\"%b\">\n", XMLKEY_BEARDUSESHAIRCOLOR, (beardUsesHairColor != 0)));
		out.write(indent + "\t\t\t\t<HairColors>\n");
		writeXmlSub_HairColor(out, indent + "\t\t\t\t\t", facialHairColors0);
		writeXmlSub_HairColor(out, indent + "\t\t\t\t\t", facialHairColors1);
		writeXmlSub_HairColor(out, indent + "\t\t\t\t\t", facialHairColors2);
		writeXmlSub_HairColor(out, indent + "\t\t\t\t\t", facialHairColors3);
		out.write(indent + "\t\t\t\t</HairColors>\n");
		out.write(indent + "\t\t\t</FacialHair>\n");
		out.write(indent + "\t\t</Face>\n");
		out.write(indent + "\t\t<Body");
		out.write(String.format(" %s=\"%b\">\n", XMLKEY_BODYHAIRUSESHAIRCOLOR, (bodyHairUsesHairColor != 0)));
		writeXmlSub_HairColor(out, indent + "\t\t\t", bodyHairColor);
		out.write(indent + "\t\t\t<GeneticStyleKeys>\n");
		out.write(indent + String.format("\t\t\t\t<StyleKey Value=\"%d\"/>\n", mGeneticBodyhairStyleKeys0));
		out.write(indent + String.format("\t\t\t\t<StyleKey Value=\"%d\"/>\n", mGeneticBodyhairStyleKeys1));
		out.write(indent + String.format("\t\t\t\t<StyleKey Value=\"%d\"/>\n", mGeneticBodyhairStyleKeys2));
		out.write(indent + String.format("\t\t\t\t<StyleKey Value=\"%d\"/>\n", mGeneticBodyhairStyleKeys3));
		out.write(indent + String.format("\t\t\t\t<StyleKey Value=\"%d\"/>\n", mGeneticBodyhairStyleKeys4));
		out.write(indent + String.format("\t\t\t\t<StyleKey Value=\"%d\"/>\n", mGeneticBodyhairStyleKeys5));
		out.write(indent + String.format("\t\t\t\t<StyleKey Value=\"%d\"/>\n", mGeneticBodyhairStyleKeys6));
		out.write(indent + String.format("\t\t\t\t<StyleKey Value=\"%d\"/>\n", mGeneticBodyhairStyleKeys7));
		out.write(indent + "\t\t\t</GeneticStyleKeys>\n");
		out.write(indent + "\t\t</Body>\n");
		out.write(indent + "\t</Hair>\n");
		
		//Body Shape
		out.write(indent + "\t<Shape");
		out.write(String.format(" %s=\"%.3f\"", XMLKEY_MFITNESSSHAPEDELTA, mFitnessShapeDelta));
		out.write(String.format(" %s=\"%.3f\"", XMLKEY_MWEIGHTSHAPEDELTA, mWeightShapeDelta));
		out.write(String.format(" %s=\"%.3f\"", XMLKEY_MSHAPEDELTAMULTIPLIER, mShapeDeltaMultiplier));
		out.write(String.format(" %s=\"%.3f\"", XMLKEY_MSECONDARYNORMALMAPWEIGHTS0, mSecondaryNormalMapWeights0));
		out.write(String.format(" %s=\"%.3f\"", XMLKEY_MSECONDARYNORMALMAPWEIGHTS1, mSecondaryNormalMapWeights1));
		out.write(">\n");
		mInitialShape.writeXMLNode(out, indent + "\t\t", XMLKEY_MINITIALSHAPE);
		mCurrentShape.writeXMLNode(out, indent + "\t\t", XMLKEY_MCURRENTSHAPE);
		surgeryBlends.writeXMLNode(out, indent + "\t\t", XMLKEY_SURGERYBLENDS);
		out.write(indent + "\t</Shape>\n");
		
		if(healthManager != null) healthManager.writeXMLNode(out, indent + "\t", XMLKEY_HEALTHMANAGER);
		out.write(indent + "</PhysAttributes>\n");
	}
	
	private void writeXml_Style(Writer out, String indent) throws IOException {
		out.write(indent + "<Style");
		out.write(String.format(" %s=\"%b\"", XMLKEY_PROPAGATEHAIRSTYLE, (propagateHairStyle != 0)));
		out.write(String.format(" %s=\"%d\"", XMLKEY_MDEFAULTOUTFITKEY, mDefaultOutfitKey));
		out.write(">\n");
		mOutfits.writeXMLNode(out, indent + "\t", XMLKEY_MOUTFITS);
		mSpecialOutfitIndices.writeXMLNode(out, indent + "\t", XMLKEY_MSPECIALOUTFITINDICES);
		out.write(indent + "</Style>\n");
	}
	
	private void writeXml_Death(Writer out, String indent) throws IOException {
		out.write(indent + "<Death");
		out.write(String.format(" %s=\"%b\"", XMLKEY_ISGHOST, isGhost));
		out.write(String.format(" %s=\"%s\"", XMLKEY_MDEATHSTYLE, DeathType.stringFromValue(mDeathStyle)));
		out.write("/>\n");
	}
	
	private void writeXml_LifetimeHappiness(Writer out, String indent) throws IOException {
		out.write(indent + "<LifetimeHappiness");
		out.write(String.format(" %s=\"%.3f\"", XMLKEY_MLIFETIMEHAPPINESS, mLifetimeHappiness));
		out.write(String.format(" %s=\"%.3f\"", XMLKEY_MSPENDABLEHAPPINESS, mSpendableHappiness));
		out.write(String.format(" %s=\"0x%08x\"", XMLKEY_LIFETIMEWISH, lifetimeWish));
		out.write(String.format(" %s=\"%b\"", XMLKEY_HASCOMPLETEDLIFETIMEWISH, hasCompletedLifetimeWish));
		out.write(">\n");
		if(dnPExportData != null) dnPExportData.writeXMLNode(out, indent + "\t", XMLKEY_DNPEXPORTDATA);
		out.write(indent + "</LifetimeHappiness>\n");
	}
	
	private void writeXml_Favorites(Writer out, String indent) throws IOException {
		out.write(indent + "<Favorites");
		out.write(String.format(" %s=\"%s\"", XMLKEY_MFAVOURITEMUSICTYPE, FavoriteMusicType.stringFromValue(mFavouriteMusicType)));
		out.write(String.format(" %s=\"%s\"", XMLKEY_MFAVOURITEFOODTYPE, FavoriteFoodType.stringFromValue(mFavouriteFoodType)));
		out.write(String.format(" %s=\"0x%08x\"", XMLKEY_MFAVOURITECOLORARGB, mFavouriteColorARGB));
		out.write(String.format(" %s=\"%d\"", XMLKEY_MPREFERREDVEHICLEGUID, mPreferredVehicleGuid));
		out.write("/>\n");
	}
	
	private void writeXml_Academics(Writer out, String indent) throws IOException {
		out.write(indent + "<Academics");
		out.write(String.format(" %s=\"%s\"", XMLKEY_ALMAMATER, AlmaMater.stringFromValue(almaMater)));
		out.write(String.format(" %s=\"%s\"", XMLKEY_MALMAMATERNAME, mAlmaMaterName));
		out.write(String.format(" %s=\"%s\"", XMLKEY_GRADUATIONTYPE, GraduationType.stringFromValue(graduationType)));
		out.write(">\n");
		if(degreeManager != null) degreeManager.writeXMLNode(out, indent + "\t", XMLKEY_DEGREEMANAGER);
		out.write(indent + "</Academics>\n");
	}
	
	private void writeXml_Career(Writer out, String indent) throws IOException {
		out.write(indent + "<Career");
		out.write(String.format(" %s=\"%b\"", XMLKEY_CANBEKILLEDONJOB, canBeKilledOnJob));
		out.write(String.format(" %s=\"%s\"", XMLKEY_SERVICEHISTORY, ServiceType.stringFromValue(serviceHistory)));
		out.write(">\n");
		careerManager.writeXMLNode(out, indent + "\t", XMLKEY_CAREERMANAGER);
		out.write(indent + "</Career>\n");
	}
	
	private void writeXml_Family(Writer out, String indent) throws IOException {
		out.write(indent + "<Family");
		out.write(String.format(" %s=\"%b\"", XMLKEY_ISPREGNANT, isPregnant));
		out.write(String.format(" %s=\"%b\"", XMLKEY_ISVISUALLYPREGNANT, isVisuallyPregnant));
		out.write(">\n");
		mGenealogy.writeXMLNode(out, indent + "\t", XMLKEY_MGENEALOGY);
		if(pregnancy != null) pregnancy.writeXMLNode(out, indent + "\t", XMLKEY_PREGNANCY);
		out.write(indent + "</Family>\n");
	}
	
	private void writeXml_Skills(Writer out, String indent) throws IOException {
		out.write(indent + "<Skills");
		out.write(String.format(" %s=\"%s\"", XMLKEY_KNOWNSNOWMANTYPES, SnowmanFlagType.stringFromValue(knownSnowmanTypes)));
		//out.write(String.format(" %s=\"%d\"", XMLKEY_READBOOKCOUNT, readBookCount));
		out.write(">\n");
		if(readBookDataList != null && !readBookDataList.isEmpty()) {
			out.write(indent + "\t<ReadBooks>\n");
			for(ReadBookInstance readBookData : readBookDataList){
				readBookData.writeXMLNode(out, indent + "\t\t", null);
			}
			out.write(indent + "\t</ReadBooks>\n");	
		}
		if(singing != null) singing.writeXMLNode(out, indent + "\t", XMLKEY_SINGING);
		skillManager.writeXMLNode(out, indent + "\t", XMLKEY_SKILLMANAGER);
		out.write(indent + "</Skills>\n");
	}
	
	private void writeXml_Traits(Writer out, String indent) throws IOException {
		out.write(indent + "<Traits>\n");
		//out.write(String.format(" %s=\"0x%08x\"", XMLKEY_TRAITCOUNT, traitCount));
		if(traitGuids != null){
			out.write(indent + "\t<TraitList>\n");
			for(int i = 0; i < traitCount; i++){
				out.write(indent + String.format("\t\t<Trait EnumString=\"%s\"/>\n", TraitNames.stringFromValue(traitGuids[i])));
			}
			out.write(indent + "\t</TraitList>\n");
		}
		if(petManager != null) petManager.writeXMLNode(out, indent + "\t", XMLKEY_PETMANAGER);
		if(mTraitChipManager != null) mTraitChipManager.writeXMLNode(out, indent + "\t", XMLKEY_MTRAITCHIPMANAGER);
		traitManager.writeXMLNode(out, indent + "\t", XMLKEY_TRAITMANAGER);
		out.write(indent + "</Traits>\n");
	}
	
	private void writeXml_Occult(Writer out, String indent) throws IOException {
		out.write(indent + "<Occult");
		out.write(String.format(" %s=\"%s\"", XMLKEY_OCCULTTYPE, OccultTypes.stringFromValue(occultType)));
		out.write(String.format(" %s=\"0x%08x\"", XMLKEY_SSUPERNATURALVERSIONNUMBER, sSupernaturalVersionNumber));
		out.write(String.format(" %s=\"%s\"", XMLKEY_MOCCULTTYPE, OccultTypes.stringFromValue(mOccultType)));
		out.write(">\n");
		occultManager.writeXMLNode(out, indent + "\t", XMLKEY_OCCULTMANAGER);
		out.write(indent + "</Occult>\n");
	}
	
	private void writeXml_WorldTravel(Writer out, String indent) throws IOException {
		out.write(indent + "<WorldTravel>\n");
		visaManager.writeXMLNode(out, indent + "\t", XMLKEY_VISAMANAGER);
		if(relicStats != null) relicStats.writeXMLNode(out, indent + "\t", XMLKEY_RELICSTATS);
		if(tombStats != null) tombStats.writeXMLNode(out, indent + "\t", XMLKEY_TOMBSTATS);
		out.write(indent + "</WorldTravel>\n");
	}
	
	private void writeXml_Social(Writer out, String indent) throws IOException {
		out.write(indent + "<Social>\n");
		celebrityManager.writeXMLNode(out, indent + "\t", XMLKEY_CELEBRITYMANAGER);
		if(mReputation != null) mReputation.writeXMLNode(out, indent + "\t", XMLKEY_MREPUTATION);
		if(socialExpTraveling != null) socialExpTraveling.writeXMLNode(out, indent + "\t", XMLKEY_SOCIALEXPTRAVELING);
		out.write(indent + "</Social>\n");
	}
	
	private void writeXml_LifeEvents(Writer out, String indent) throws IOException {
		out.write(indent + "<LifeEvents>\n");
		lifeEventManager.writeXMLNode(out, indent + "\t", XMLKEY_LIFEEVENTMANAGER);
		if(midlifeCrisisManager != null) midlifeCrisisManager.writeXMLNode(out, indent + "\t", XMLKEY_MIDLIFECRISISMANAGER);
		out.write(indent + "</LifeEvents>\n");
	}
	
	private void writeXml_Opportunities(Writer out, String indent) throws IOException {
		out.write(indent + "<Opportunities");
		out.write(String.format(" %s=\"%b\"", XMLKEY_NEEDSOPPORTUNITYIMPORT, needsOpportunityImport));
		out.write(">\n");
		if(opportunityHistory != null) opportunityHistory.writeXMLNode(out, indent + "\t", XMLKEY_OPPORTUNITYHISTORY);
		out.write(indent + "</Opportunities>\n");
	}
	
	private void writeXml_Mood(Writer out, String indent) throws IOException {
		if(travelBuffs == null) return;
		out.write(indent + "<Mood>\n");
		if(travelBuffs != null) travelBuffs.writeXMLNode(out, indent + "\t", XMLKEY_TRAVELBUFFS);
		out.write(indent + "</Mood>\n");
	}
	
	public void writeXMLNode(Writer out, String indent, String varName) throws IOException {
		if(out == null) return;
		if(indent == null) indent = "";
		
		if(traitGuids != null) {
			traitCount = traitGuids.length;
		}
		else traitCount = 0;
		readBookCount = readBookDataList.size();
		
		out.write(indent);
		out.write(String.format("<%s", xmlNodeName));
		if(varName != null){
			out.write(String.format(" VarName=\"%s\"", varName));
		}
		out.write(String.format(" %s=\"0x%016x\"", XMLKEY_SIMDESCRIPTIONID, simDescriptionId));
		out.write(String.format(" %s=\"%b\"", XMLKEY_ISNEVERSELECTABLE, isNeverSelectable));
		out.write(String.format(" %s=\"%b\"", XMLKEY_MARRYABLE, marryable));
		out.write(String.format(" %s=\"%b\"", XMLKEY_CONTACTABLE, contactable));
		out.write(">\n");
		
		writeXml_Basics(out, indent + "\t");
		writeXml_Physical(out, indent + "\t");
		writeXml_Aging(out, indent + "\t");
		writeXml_Death(out, indent + "\t");
		writeXml_Style(out, indent + "\t");
		writeXml_Favorites(out, indent + "\t");
		writeXml_Family(out, indent + "\t");
		writeXml_Occult(out, indent + "\t");
		writeXml_Traits(out, indent + "\t");
		writeXml_Skills(out, indent + "\t");
		writeXml_Social(out, indent + "\t");
		writeXml_Academics(out, indent + "\t");
		writeXml_Career(out, indent + "\t");
		writeXml_LifeEvents(out, indent + "\t");
		writeXml_Opportunities(out, indent + "\t");
		writeXml_WorldTravel(out, indent + "\t");
		writeXml_LifetimeHappiness(out, indent + "\t");
		writeXml_Mood(out, indent + "\t");
		
		out.write(indent);
		out.write(String.format("</%s>\n", xmlNodeName));
	}

	public void addToPropertyStream(MaxisPropertyStream ps) {	
		if(ps == null) return;
		boolean byte_order = ps.getByteOrder();
		int verFieldSize = ps.getVersionFieldSize();
		
		if(traitGuids != null) {
			traitCount = traitGuids.length;
		}
		else traitCount = 0;
		readBookCount = readBookDataList.size();
		int i = 0;
		
		ps.addLong(simDescriptionId, PSID_SIMDESCRIPTIONID, false);
		ps.addInt(mSimFlags, PSID_MSIMFLAGS, false);
		ps.addFloat(agingYearsSinceLastAgeTransition, PSID_AGINGYEARSSINCELASTAGETRANSITION);
		ps.addInt(userDaysInCurrentAge, PSID_USERDAYSINCURRENTAGE, true);
		ps.addInt(mSkinToneKey, PSID_MSKINTONEKEY, true);
		ps.addFloat(mSkinToneIndex, PSID_MSKINTONEINDEX);
		ps.addFloat(mSecondaryNormalMapWeights0, PSID_MSECONDARYNORMALMAPWEIGHTS0);
		ps.addFloat(mSecondaryNormalMapWeights1, PSID_MSECONDARYNORMALMAPWEIGHTS1);
		ps.addInt(mDefaultOutfitKey, PSID_MDEFAULTOUTFITKEY, true);
		ps.addIntArray(hairColors0, PSID_HAIRCOLORS0, false);
		ps.addIntArray(hairColors1, PSID_HAIRCOLORS1, false);
		ps.addIntArray(hairColors2, PSID_HAIRCOLORS2, false);
		ps.addIntArray(hairColors3, PSID_HAIRCOLORS3, false);
		ps.addIntArray(eyebrowColor, PSID_EYEBROWCOLOR, false);
		ps.addIntArray(bodyHairColor, PSID_BODYHAIRCOLOR, false);
		ps.addIntArray(facialHairColors0, PSID_FACIALHAIRCOLORS0, false);
		ps.addIntArray(facialHairColors1, PSID_FACIALHAIRCOLORS1, false);
		ps.addIntArray(facialHairColors2, PSID_FACIALHAIRCOLORS2, false);
		ps.addIntArray(facialHairColors3, PSID_FACIALHAIRCOLORS3, false);
		ps.addInt(beardUsesHairColor, PSID_BEARDUSESHAIRCOLOR, false);
		ps.addInt(eyebrowsUseHairColor, PSID_EYEBROWSUSEHAIRCOLOR, false);
		ps.addInt(bodyHairUsesHairColor, PSID_BODYHAIRUSESHAIRCOLOR, false);
		ps.addInt(propagateHairStyle, PSID_PROPAGATEHAIRSTYLE, false);
		if(mHousehold != 0L) ps.addLong(mHousehold, PSID_MHOUSEHOLD, false);
		ps.addString(mFirstName, PSID_MFIRSTNAME);
		ps.addString(mLastName, PSID_MLASTNAME);
		ps.addInt(mDeathStyle, PSID_MDEATHSTYLE, false);
		ps.addBool(isNeverSelectable, PSID_ISNEVERSELECTABLE);
		ps.addBool(agingEnabled, PSID_AGINGENABLED);
		ps.addFloat(mLifetimeHappiness, PSID_MLIFETIMEHAPPINESS);
		ps.addFloat(mSpendableHappiness, PSID_MSPENDABLEHAPPINESS);
		ps.addInt(mFavouriteMusicType, PSID_MFAVOURITEMUSICTYPE, false);
		ps.addInt(mFavouriteFoodType, PSID_MFAVOURITEFOODTYPE, false);
		ps.addInt(mFavouriteColorARGB, PSID_MFAVOURITECOLORARGB, false);
		ps.addString(mBio, PSID_MBIO);
		ps.addInt(mZodiacSign, PSID_MZODIACSIGN, false);
		ps.addInt(almaMater, PSID_ALMAMATER, false);
		ps.addString(mAlmaMaterName, PSID_MALMAMATERNAME);
		ps.addInt(graduationType, PSID_GRADUATIONTYPE, false);
		ps.addLong(serviceHistory, PSID_SERVICEHISTORY, false);
		ps.addBool(marryable, PSID_MARRYABLE);
		ps.addBool(canBeKilledOnJob, PSID_CANBEKILLEDONJOB);
		ps.addBool(isGhost, PSID_ISGHOST);
		ps.addBool(contactable, PSID_CONTACTABLE);
		ps.addBool(isPregnant, PSID_ISPREGNANT);
		ps.addBool(isVisuallyPregnant, PSID_ISVISUALLYPREGNANT);
		ps.addFloat(alienDNAPercentage, PSID_ALIENDNAPERCENTAGE);
		ps.addChildStream(mInitialShape.toPropertyStream(byte_order, verFieldSize), PSID_MINITIALSHAPE);
		ps.addChildStream(mCurrentShape.toPropertyStream(byte_order, verFieldSize), PSID_MCURRENTSHAPE);
		ps.addFloat(mFitnessShapeDelta, PSID_MFITNESSSHAPEDELTA);
		ps.addFloat(mWeightShapeDelta, PSID_MWEIGHTSHAPEDELTA);
		ps.addFloat(mShapeDeltaMultiplier, PSID_MSHAPEDELTAMULTIPLIER);
		ps.addInt(mVoiceVariation, PSID_MVOICEVARIATION, false);
		ps.addFloat(mVoicePitchModifier, PSID_MVOICEPITCHMODIFIER);
		ps.addInt(mGeneticHairstyleKey, PSID_MGENETICHAIRSTYLEKEY, true);
		ps.addInt(mGeneticBodyhairStyleKeys0, PSID_MGENETICBODYHAIRSTYLEKEYS0, true);
		ps.addInt(mGeneticBodyhairStyleKeys1, PSID_MGENETICBODYHAIRSTYLEKEYS1, true);
		ps.addInt(mGeneticBodyhairStyleKeys2, PSID_MGENETICBODYHAIRSTYLEKEYS2, true);
		ps.addInt(mGeneticBodyhairStyleKeys3, PSID_MGENETICBODYHAIRSTYLEKEYS3, true);
		ps.addInt(mGeneticBodyhairStyleKeys4, PSID_MGENETICBODYHAIRSTYLEKEYS4, true);
		ps.addInt(mGeneticBodyhairStyleKeys5, PSID_MGENETICBODYHAIRSTYLEKEYS5, true);
		ps.addInt(mGeneticBodyhairStyleKeys6, PSID_MGENETICBODYHAIRSTYLEKEYS6, true);
		ps.addInt(mGeneticBodyhairStyleKeys7, PSID_MGENETICBODYHAIRSTYLEKEYS7, true);
		ps.addInt(mHomeWorld, PSID_MHOMEWORLD, true);
		ps.addChildStream(mOutfits.toPropertyStream(byte_order, verFieldSize), PSID_MOUTFITS);
		
		//(See parser) This one might be bugged.
		//ps.addChildStream(mSpecialOutfitIndices.toPropertyStream(byte_order, verFieldSize), PSID_MSPECIALOUTFITINDICES);
		mSpecialOutfitIndices.addToPropertyStream(ps);
		
		if(traitGuids != null) {
			ps.addInt(traitCount, PSID_TRAITCOUNT, false);
			ps.addLongArray(traitGuids, PSID_TRAITGUIDS, false);
		}
		ps.addChildStream(traitManager.toPropertyStream(byte_order, verFieldSize), PSID_TRAITMANAGER);
		ps.addChildStream(mGenealogy.toPropertyStream(byte_order, verFieldSize), PSID_MGENEALOGY);
		ps.addInt(lifetimeWish, PSID_LIFETIMEWISH, false);
		ps.addBool(hasCompletedLifetimeWish, PSID_HASCOMPLETEDLIFETIMEWISH);
		
		if(occultType != OccultTypes.None) {
			ps.addInt(occultType, PSID_OCCULTTYPE, false);
			ps.addInt(sSupernaturalVersionNumber, PSID_SSUPERNATURALVERSIONNUMBER, false);
			ps.addInt(mOccultType, PSID_MOCCULTTYPE, false);	
		}
		
		ps.addChildStream(skillManager.toPropertyStream(byte_order, verFieldSize), PSID_SKILLMANAGER);
		ps.addChildStream(careerManager.toPropertyStream(byte_order, verFieldSize), PSID_CAREERMANAGER);
		ps.addChildStream(visaManager.toPropertyStream(byte_order, verFieldSize), PSID_VISAMANAGER);
		ps.addChildStream(celebrityManager.toPropertyStream(byte_order, verFieldSize), PSID_CELEBRITYMANAGER);
		ps.addChildStream(lifeEventManager.toPropertyStream(byte_order, verFieldSize), PSID_LIFEEVENTMANAGER);
		ps.addChildStream(occultManager.toPropertyStream(byte_order, verFieldSize), PSID_OCCULTMANAGER);
		if(healthManager != null) ps.addChildStream(healthManager.toPropertyStream(byte_order, verFieldSize), PSID_HEALTHMANAGER);
		if(mReputation != null) ps.addChildStream(mReputation.toPropertyStream(byte_order, verFieldSize), PSID_MREPUTATION);
		if(midlifeCrisisManager != null) ps.addChildStream(midlifeCrisisManager.toPropertyStream(byte_order, verFieldSize), PSID_MIDLIFECRISISMANAGER);
		if(petManager != null) ps.addChildStream(petManager.toPropertyStream(byte_order, verFieldSize), PSID_PETMANAGER);
		
		ps.addInt(readBookCount, PSID_READBOOKCOUNT, true);
		i = 0;
		for(ReadBookInstance readBookData : readBookDataList){
			readBookData.psidKey = PSID_READBOOKDATALIST + i;
			readBookData.psidData = PSID_READBOOKDATABASE + i;
			readBookData.addToPropertyStream(ps);
			i++;
		}
		
		if(pregnancy != null) ps.addChildStream(pregnancy.toPropertyStream(byte_order, verFieldSize), PSID_PREGNANCY);
		if(opportunityHistory != null) ps.addChildStream(opportunityHistory.toPropertyStream(byte_order, verFieldSize), PSID_OPPORTUNITYHISTORY);
		ps.addBool(needsOpportunityImport, PSID_NEEDSOPPORTUNITYIMPORT);
		if(dnPExportData != null) ps.addChildStream(dnPExportData.toPropertyStream(byte_order, verFieldSize), PSID_DNPEXPORTDATA);
		if(relicStats != null) ps.addChildStream(relicStats.toPropertyStream(byte_order, verFieldSize), PSID_RELICSTATS);
		if(tombStats != null)ps.addChildStream(tombStats.toPropertyStream(byte_order, verFieldSize), PSID_TOMBSTATS);
		if(travelBuffs != null) ps.addChildStream(travelBuffs.toPropertyStream(byte_order, verFieldSize), PSID_TRAVELBUFFS);
		if(mPreferredVehicleGuid != 0L) ps.addInt(mPreferredVehicleGuid, PSID_MPREFERREDVEHICLEGUID, true);
		if(singing != null) ps.addChildStream(singing.toPropertyStream(byte_order, verFieldSize), PSID_SINGING);
		if(socialExpTraveling != null) socialExpTraveling.addToPropertyStream(ps);
		ps.addByte(knownSnowmanTypes, PSID_KNOWNSNOWMANTYPES);
		surgeryBlends.addToPropertyStream(ps);
		if(degreeManager != null) ps.addChildStream(degreeManager.toPropertyStream(byte_order, verFieldSize), PSID_DEGREEMANAGER);
		if(mTraitChipManager != null) ps.addChildStream(mTraitChipManager.toPropertyStream(byte_order, verFieldSize), PSID_MTRAITCHIPMANAGER);
	}
	
}
