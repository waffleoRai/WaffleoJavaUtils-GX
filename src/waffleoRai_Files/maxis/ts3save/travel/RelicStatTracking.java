/*-----------------------------------------------------
 * Autogenerated Java class from XML definition.
 * Created Wed, 1 Jan 2025 13:25:45 -0600
 *-----------------------------------------------------*/

//Last check pass: 2025/01/01 23:49

package waffleoRai_Files.maxis.ts3save.travel;

import java.io.IOException;
import java.io.Writer;
import java.util.ArrayList;
import java.util.List;

import org.w3c.dom.Element;

import waffleoRai_Containers.maxis.MaxisPropertyStream;
import waffleoRai_Containers.maxis.MaxisTypes;
import waffleoRai_Files.XMLReader;
import waffleoRai_Files.maxis.ts3enum.CollectableRelicGuid;
import waffleoRai_Files.maxis.ts3enum.CollectableRelicType;
import waffleoRai_Files.maxis.ts3save.TS3Saveable;
import waffleoRai_Utils.BufferReference;
import waffleoRai_Utils.FileBuffer;
import waffleoRai_Utils.StringUtils;

public class RelicStatTracking extends TS3Saveable{
//TS3 Script: Sims3.Gameplay.Skills.RelicStatTracking
	
	public static final int TRASH_RELICS_LEN = 0;
	public static final int COLL_RELICS_LEN = 0;
	public static final int OPPS_LEN = 0;

	public static final int PSID_MNUMDIGSITESEXCAVATED = 0x08A119CF;
	public static final int PSID_MMOSTVALUABLETRASHRELIC = 0x08A119D3;
	public static final int PSID_MMOSTVALUABLECOLLECTABLERELIC = 0x08A119D7;
	public static final int PSID_MAGEOFOLDESTTRASHRELIC = 0x08A119DC;
	public static final int PSID_MAGEOFOLDESTCOLLECTABLERELIC = 0x08A119E1;
	public static final int PSID_MNUMTRASHRELICSANALYZED = 0x08A119E4;
	public static final int PSID_MNUMCOLLECTABLERELICSANALYZED = 0x08A119EA;
	public static final int PSID_MMONEYEARNEDSELLINGTRASHRELICS = 0x08A119EF;
	public static final int PSID_MMONEYEARNEDSELLINGCOLLECTABLERELICS = 0x08A119F3;
	public static final int PSID_MNUMBERCOLLECTIONSCOMPLETED = 0x08A119F8;
	public static final int PSID_MHISTORICALHOARDERISNEW = 0x08A11A08;
	public static final int PSID_MRELICCOLLECTIONCONNOISSEURISNEW = 0x08A11A10;
	public static final int PSID_MNUMTRASHRELICSFOUNDPERCULTURE = 0x08A120EB;
	public static final int PSID_MNUMCOLLECTABLERELICSFOUNDPERCULTURE = 0x08A120D8;
	public static final int PSID_RELICCOLLECTIONTYPEMAP = 0x08A13ADC;
	public static final int PSID_MLIFETIMEOPPSSHOWN = 0x08B509E9;

	private static final String XMLKEY_MNUMDIGSITESEXCAVATED = "NumDigSitesExcavated";
	private static final String XMLKEY_MMOSTVALUABLETRASHRELIC = "MostValuableTrashRelic";
	private static final String XMLKEY_MMOSTVALUABLECOLLECTABLERELIC = "MostValuableCollectableRelic";
	private static final String XMLKEY_MAGEOFOLDESTTRASHRELIC = "AgeOfOldestTrashRelic";
	private static final String XMLKEY_MAGEOFOLDESTCOLLECTABLERELIC = "AgeOfOldestCollectableRelic";
	private static final String XMLKEY_MNUMTRASHRELICSANALYZED = "NumTrashRelicsAnalyzed";
	private static final String XMLKEY_MNUMCOLLECTABLERELICSANALYZED = "NumCollectableRelicsAnalyzed";
	private static final String XMLKEY_MMONEYEARNEDSELLINGTRASHRELICS = "MoneyEarnedSellingTrashRelics";
	private static final String XMLKEY_MMONEYEARNEDSELLINGCOLLECTABLERELICS = "MoneyEarnedSellingCollectableRelics";
	private static final String XMLKEY_MNUMBERCOLLECTIONSCOMPLETED = "NumberCollectionsCompleted";
	private static final String XMLKEY_MHISTORICALHOARDERISNEW = "HistoricalHoarderIsNew";
	private static final String XMLKEY_MRELICCOLLECTIONCONNOISSEURISNEW = "RelicCollectionConnoisseurIsNew";
	private static final String XMLKEY_MNUMTRASHRELICSFOUNDPERCULTURE = "NumTrashRelicsFoundPerCulture";
	private static final String XMLKEY_MNUMCOLLECTABLERELICSFOUNDPERCULTURE = "NumCollectableRelicsFoundPerCulture";
	private static final String XMLKEY_RELICCOLLECTIONTYPEMAP = "RelicCollectionTypeMap";
	private static final String XMLKEY_MLIFETIMEOPPSSHOWN = "LifetimeOppsShown";

	public int mNumDigSitesExcavated;
	public int mMostValuableTrashRelic;
	public int mMostValuableCollectableRelic;
	public int mAgeOfOldestTrashRelic;
	public int mAgeOfOldestCollectableRelic;
	public int mNumTrashRelicsAnalyzed;
	public int mNumCollectableRelicsAnalyzed;
	public int mMoneyEarnedSellingTrashRelics;
	public int mMoneyEarnedSellingCollectableRelics;
	public int mNumberCollectionsCompleted;
	public boolean mHistoricalHoarderIsNew;
	public boolean mRelicCollectionConnoisseurIsNew;
	public int[] mNumTrashRelicsFoundPerCulture;
	public int[] mNumCollectableRelicsFoundPerCulture;
	public RelicCollectionTypeMap relicCollectionTypeMap;
	public boolean[] mLifetimeOppsShown;

	public RelicStatTracking() {
		xmlNodeName = "RelicStatTracking";
		baseSize = 51;
	}
	
	/*----- Inner Classes -----*/

	public static class RelicCollectionTypeMap extends TS3Saveable{

		public static final int PSID_RELICTYPECOUNT = 0x00000000;
		public static final int PSID_RELICTYPES = 0x00000001;

		private static final String XMLKEY_RELICTYPECOUNT = "RelicTypeCount";
		private static final String XMLKEY_RELICTYPES = "RelicTypes";

		public int relicTypeCount;
		public ArrayList<RelicType> relicTypes = new ArrayList<RelicType>();

		public RelicCollectionTypeMap() {
			xmlNodeName = "RelicCollectionTypeMap";
			baseSize = 4;
		}
		
		/*----- Read -----*/
		
		protected boolean readBinary_internal(BufferReference dat) {
			if(dat == null) return false;
			
			relicTypeCount = dat.nextInt();
			relicTypes.ensureCapacity(relicTypeCount);
			for(int i = 0; i < relicTypeCount; i++){
				RelicType relicType = RelicType.readBinary(dat);
				if(relicType != null) relicTypes.add(relicType);
			}

			return true;
		}
		
		protected boolean readXMLNode_internal(Element xml_element) {
			if(xml_element == null) return false;
			String nn = xml_element.getNodeName();
			if(nn == null) return false;
			if(!nn.equals(xmlNodeName)) return false;
			
			String aval = null;
			Element child = null;
			aval = xml_element.getAttribute(XMLKEY_RELICTYPECOUNT);
			if(aval != null) relicTypeCount = StringUtils.parseSignedInt(aval);
			child = XMLReader.getFirstChildElementWithTagAndAttribute(xml_element, "List", "VarName", XMLKEY_RELICTYPES);
			if(child != null){
				relicTypes.ensureCapacity(relicTypeCount);
				List<Element> gclist = XMLReader.getChildElementsWithTag(child, "RelicType");
				for(Element gc : gclist){
					relicTypes.add(RelicType.readXMLNode(gc));
				}
			}

			return true;
		}
		
		protected boolean readPropertyStream_internal(MaxisPropertyStream stream) {
			if(stream == null) return false;
			
			relicTypeCount = stream.getFieldAsInt(PSID_RELICTYPECOUNT, true);
			relicTypes.ensureCapacity(relicTypeCount);
			for(int i = 0; i < relicTypeCount; i++){
				RelicType relicType = RelicType.readBinary(stream.getFieldAsBlob(PSID_RELICTYPES + i).getReferenceAt(0L));
				if(relicType != null) relicTypes.add(relicType);
			}

			return true;
		}
		
		public static RelicCollectionTypeMap readBinary(BufferReference dat) {
			if(dat == null) return null;
			RelicCollectionTypeMap str = new RelicCollectionTypeMap();
			if(!str.readBinary_internal(dat)) return null;
			return str;
		}
		
		public static RelicCollectionTypeMap readXMLNode(Element xml_element) {
			if(xml_element == null) return null;
			RelicCollectionTypeMap str = new RelicCollectionTypeMap();
			if(!str.readXMLNode_internal(xml_element)) return null;
			return str;
		}
		
		public static RelicCollectionTypeMap readPropertyStream(BufferReference dat, boolean byteOrder, int verFieldSize) {
			if(dat == null) return null;
			MaxisPropertyStream stream = MaxisPropertyStream.openForRead(dat, byteOrder, verFieldSize);
			return readPropertyStream(stream);
		}
		
		public static RelicCollectionTypeMap readPropertyStream(MaxisPropertyStream stream) {
			if(stream == null) return null;
			RelicCollectionTypeMap str = new RelicCollectionTypeMap();
			if(!str.readPropertyStream_internal(stream));
			return str;
		}
		
		/*----- Write -----*/
		
		public int getBinarySize() {
			int size = baseSize;
			for(RelicType relicTypes : relicTypes){
				size += relicTypes.getBinarySize();
			}
			return size;
		}
		
		public FileBuffer writeBinary(boolean byteOrder) {
			FileBuffer buff = new FileBuffer(getBinarySize(), byteOrder);
			writeBinaryTo(buff);
			return buff;
		}
		
		public int writeBinaryTo(FileBuffer target) {
			if(target == null) return 0;
			long stPos = target.getFileSize();
			
			relicTypeCount = relicTypes.size();
			target.addToFile(relicTypeCount);
			for(RelicType relicTypes : relicTypes){
				relicTypes.writeBinaryTo(target);
			}

			return (int)(target.getFileSize() - stPos);
		}
	
		public void writeXMLNode(Writer out, String indent) throws IOException {
			writeXMLNode(out, indent, null);
		}
		
		public void writeXMLNode(Writer out, String indent, String varName) throws IOException {
			if(out == null) return;
			if(indent == null) indent = "";
			
			relicTypeCount = relicTypes.size();
			out.write(indent);
			out.write(String.format("<%s", xmlNodeName));
			if(varName != null){
				out.write(String.format(" VarName=\"%s\"", varName));
			}
			out.write(String.format(" %s=\"%d\"", XMLKEY_RELICTYPECOUNT, relicTypeCount));
			out.write(">\n");
			out.write(indent + "\t<List ");
			out.write(String.format(" VarName=\"%s\">\n", XMLKEY_RELICTYPES));
			for(RelicType relicTypes : relicTypes){
				relicTypes.writeXMLNode(out, indent + "\t\t", null);
			}
			out.write(indent + "\t</List>\n");
			out.write(indent);
			out.write(String.format("</%s>\n", xmlNodeName));

		}
	
		public void addToPropertyStream(MaxisPropertyStream ps) {	
			if(ps == null) return;
			relicTypeCount = relicTypes.size();
			int psidBase = PSID_RELICTYPES;
			ps.addInt(relicTypeCount, PSID_RELICTYPECOUNT, true);
			for(RelicType relicType : relicTypes){
				relicType.psidBase = psidBase;
				relicType.addToPropertyStream(ps);
				psidBase += 2;
			}
		}
		
	}

	public static class RelicType extends TS3Saveable{

		private static final String XMLKEY_RELICTYPEKEY = "RelicTypeKey";
		private static final String XMLKEY_RELICTYPEJOURNAL = "RelicTypeJournal";

		public int relicTypeKey;
		public RelicTypeJournal relicTypeJournal;
		
		public int psidBase;

		public RelicType() {
			xmlNodeName = "RelicType";
			baseSize = 4;
		}

		/*----- Read -----*/
		
		protected boolean readBinary_internal(BufferReference dat) {
			if(dat == null) return false;
			
			relicTypeKey = dat.nextInt();
			relicTypeJournal = RelicTypeJournal.readBinary(dat);

			return true;
		}
		
		protected boolean readXMLNode_internal(Element xml_element) {
			if(xml_element == null) return false;
			String nn = xml_element.getNodeName();
			if(nn == null) return false;
			if(!nn.equals(xmlNodeName)) return false;
			
			String aval = null;
			Element child = null;
			aval = xml_element.getAttribute(XMLKEY_RELICTYPEKEY);
			if(aval != null) relicTypeKey = CollectableRelicType.valueFromString(aval);
			child = XMLReader.getFirstChildElementWithTagAndAttribute(xml_element, "RelicTypeJournal", "VarName", XMLKEY_RELICTYPEJOURNAL);
			if(child != null) relicTypeJournal = RelicTypeJournal.readXMLNode(child);

			return true;
		}
		
		protected boolean readPropertyStream_internal(MaxisPropertyStream stream) {
			if(stream == null) return false;
			
			relicTypeKey = stream.getFieldAsInt(psidBase, false);
			relicTypeJournal = RelicTypeJournal.readPropertyStream(stream.getChildStream(psidBase+1));

			return true;
		}
		
		public static RelicType readBinary(BufferReference dat) {
			if(dat == null) return null;
			RelicType str = new RelicType();
			if(!str.readBinary_internal(dat)) return null;
			return str;
		}
		
		public static RelicType readXMLNode(Element xml_element) {
			if(xml_element == null) return null;
			RelicType str = new RelicType();
			if(!str.readXMLNode_internal(xml_element)) return null;
			return str;
		}
		
		public static RelicType readPropertyStream(BufferReference dat, boolean byteOrder, int verFieldSize) {
			if(dat == null) return null;
			MaxisPropertyStream stream = MaxisPropertyStream.openForRead(dat, byteOrder, verFieldSize);
			return readPropertyStream(stream);
		}
		
		public static RelicType readPropertyStream(MaxisPropertyStream stream) {
			if(stream == null) return null;
			RelicType str = new RelicType();
			if(!str.readPropertyStream_internal(stream));
			return str;
		}
		
		/*----- Write -----*/
		
		public int getBinarySize() {
			int size = baseSize;
			size += relicTypeJournal.getBinarySize();
			return size;
		}
		
		public FileBuffer writeBinary(boolean byteOrder) {
			FileBuffer buff = new FileBuffer(getBinarySize(), byteOrder);
			writeBinaryTo(buff);
			return buff;
		}
		
		public int writeBinaryTo(FileBuffer target) {
			if(target == null) return 0;
			long stPos = target.getFileSize();
			
			target.addToFile(relicTypeKey);
			relicTypeJournal.writeBinaryTo(target);

			return (int)(target.getFileSize() - stPos);
		}
	
		public void writeXMLNode(Writer out, String indent) throws IOException {
			writeXMLNode(out, indent, null);
		}
		
		public void writeXMLNode(Writer out, String indent, String varName) throws IOException {
			if(out == null) return;
			if(indent == null) indent = "";
			
			out.write(indent);
			out.write(String.format("<%s", xmlNodeName));
			if(varName != null){
				out.write(String.format(" VarName=\"%s\"", varName));
			}
			out.write(String.format(" %s=\"%s\"", XMLKEY_RELICTYPEKEY, CollectableRelicType.stringFromValue(relicTypeKey)));
			out.write(">\n");
			relicTypeJournal.writeXMLNode(out, indent + "\t", XMLKEY_RELICTYPEJOURNAL);
			out.write(indent);
			out.write(String.format("</%s>\n", xmlNodeName));

		}
	
		public void addToPropertyStream(MaxisPropertyStream ps) {	
			if(ps == null) return;
			boolean byte_order = ps.getByteOrder();
			int verFieldSize = ps.getVersionFieldSize();
			ps.addInt(relicTypeKey, psidBase, false);
			ps.addChildStream(relicTypeJournal.toPropertyStream(byte_order, verFieldSize), psidBase+1);
		}
	}

	public static class RelicTypeJournal extends TS3Saveable{

		public static final int PSID_RELICGUIDCOUNT = 0x00000000;
		public static final int PSID_RELICS = 0x00000001;

		private static final String XMLKEY_RELICGUIDCOUNT = "RelicGuidCount";
		private static final String XMLKEY_RELICS = "Relics";

		public int relicGuidCount;
		public ArrayList<RelicInstance> relics = new ArrayList<RelicInstance>();

		public RelicTypeJournal() {
			xmlNodeName = "RelicTypeJournal";
			baseSize = 4;
		}
	
		/*----- Read -----*/
		
		protected boolean readBinary_internal(BufferReference dat) {
			if(dat == null) return false;
			
			relicGuidCount = dat.nextInt();
			relics.ensureCapacity(relicGuidCount);
			for(int i = 0; i < relicGuidCount; i++){
				RelicInstance relic = RelicInstance.readBinary(dat);
				if(relic != null) relics.add(relic);
			}

			return true;
		}
		
		protected boolean readXMLNode_internal(Element xml_element) {
			if(xml_element == null) return false;
			String nn = xml_element.getNodeName();
			if(nn == null) return false;
			if(!nn.equals(xmlNodeName)) return false;
			
			String aval = null;
			Element child = null;
			aval = xml_element.getAttribute(XMLKEY_RELICGUIDCOUNT);
			if(aval != null) relicGuidCount = StringUtils.parseSignedInt(aval);
			child = XMLReader.getFirstChildElementWithTagAndAttribute(xml_element, "List", "VarName", XMLKEY_RELICS);
			if(child != null){
				relics.ensureCapacity(relicGuidCount);
				List<Element> gclist = XMLReader.getChildElementsWithTag(child, "RelicInstance");
				for(Element gc : gclist){
					relics.add(RelicInstance.readXMLNode(gc));
				}
			}

			return true;
		}
		
		protected boolean readPropertyStream_internal(MaxisPropertyStream stream) {
			if(stream == null) return false;
			
			relicGuidCount = stream.getFieldAsInt(PSID_RELICGUIDCOUNT, true);
			relics.ensureCapacity(relicGuidCount);
			
			int psid = PSID_RELICS;
			for(int i = 0; i < relicGuidCount; i++){
				RelicInstance relic = new RelicInstance();
				relic.psidBase = psid;
				relic.readPropertyStream_internal(stream);
				relics.add(relic);
				psid += 2;
			}

			return true;
		}
		
		public static RelicTypeJournal readBinary(BufferReference dat) {
			if(dat == null) return null;
			RelicTypeJournal str = new RelicTypeJournal();
			if(!str.readBinary_internal(dat)) return null;
			return str;
		}
		
		public static RelicTypeJournal readXMLNode(Element xml_element) {
			if(xml_element == null) return null;
			RelicTypeJournal str = new RelicTypeJournal();
			if(!str.readXMLNode_internal(xml_element)) return null;
			return str;
		}
		
		public static RelicTypeJournal readPropertyStream(BufferReference dat, boolean byteOrder, int verFieldSize) {
			if(dat == null) return null;
			MaxisPropertyStream stream = MaxisPropertyStream.openForRead(dat, byteOrder, verFieldSize);
			return readPropertyStream(stream);
		}
		
		public static RelicTypeJournal readPropertyStream(MaxisPropertyStream stream) {
			if(stream == null) return null;
			RelicTypeJournal str = new RelicTypeJournal();
			if(!str.readPropertyStream_internal(stream));
			return str;
		}
		
		/*----- Write -----*/
		
		public int getBinarySize() {
			int size = baseSize;
			for(RelicInstance relics : relics){
				size += relics.getBinarySize();
			}
			return size;
		}
		
		public FileBuffer writeBinary(boolean byteOrder) {
			FileBuffer buff = new FileBuffer(getBinarySize(), byteOrder);
			writeBinaryTo(buff);
			return buff;
		}
		
		public int writeBinaryTo(FileBuffer target) {
			if(target == null) return 0;
			long stPos = target.getFileSize();
			
			relicGuidCount = relics.size();
			target.addToFile(relicGuidCount);
			for(RelicInstance relics : relics){
				relics.writeBinaryTo(target);
			}

			return (int)(target.getFileSize() - stPos);
		}
	
		public void writeXMLNode(Writer out, String indent) throws IOException {
			writeXMLNode(out, indent, null);
		}
		
		public void writeXMLNode(Writer out, String indent, String varName) throws IOException {
			if(out == null) return;
			if(indent == null) indent = "";
			
			relicGuidCount = relics.size();
			out.write(indent);
			out.write(String.format("<%s", xmlNodeName));
			if(varName != null){
				out.write(String.format(" VarName=\"%s\"", varName));
			}
			out.write(String.format(" %s=\"%d\"", XMLKEY_RELICGUIDCOUNT, relicGuidCount));
			out.write(">\n");
			out.write(indent + "\t<List ");
			out.write(String.format(" VarName=\"%s\">\n", XMLKEY_RELICS));
			for(RelicInstance relics : relics){
				relics.writeXMLNode(out, indent + "\t\t", null);
			}
			out.write(indent + "\t</List>\n");
			out.write(indent);
			out.write(String.format("</%s>\n", xmlNodeName));

		}
	
		public void addToPropertyStream(MaxisPropertyStream ps) {	
			if(ps == null) return;
			relicGuidCount = relics.size();
			int psid = PSID_RELICS;
			ps.addInt(relicGuidCount, PSID_RELICGUIDCOUNT, true);
			for(RelicInstance relic : relics){
				relic.psidBase = psid;
				relic.addToPropertyStream(ps);
				psid += 2;
			}
		}
		
	}

	public static class RelicInstance extends TS3Saveable{

		private static final String XMLKEY_RELICGUIDKEY = "RelicGuidKey";
		private static final String XMLKEY_RELICJOURNALDATA = "RelicJournalData";

		public int relicGuidKey;
		public CollectableRelicJournalData relicJournalData;
		
		public int psidBase;

		public RelicInstance() {
			xmlNodeName = "RelicInstance";
			baseSize = 4;
		}
		
		/*----- Read -----*/
		
		protected boolean readBinary_internal(BufferReference dat) {
			if(dat == null) return false;
			
			relicGuidKey = dat.nextInt();
			relicJournalData = CollectableRelicJournalData.readBinary(dat);

			return true;
		}
		
		protected boolean readXMLNode_internal(Element xml_element) {
			if(xml_element == null) return false;
			String nn = xml_element.getNodeName();
			if(nn == null) return false;
			if(!nn.equals(xmlNodeName)) return false;
			
			String aval = null;
			Element child = null;
			aval = xml_element.getAttribute(XMLKEY_RELICGUIDKEY);
			if(aval != null) relicGuidKey = CollectableRelicGuid.valueFromString(aval);
			child = XMLReader.getFirstChildElementWithTagAndAttribute(xml_element, "CollectableRelicJournalData", "VarName", XMLKEY_RELICJOURNALDATA);
			if(child != null) relicJournalData = CollectableRelicJournalData.readXMLNode(child);

			return true;
		}
		
		protected boolean readPropertyStream_internal(MaxisPropertyStream stream) {
			if(stream == null) return false;
			
			relicGuidKey = stream.getFieldAsInt(psidBase, false);
			relicJournalData = CollectableRelicJournalData.readPropertyStream(stream.getChildStream(psidBase+1));

			return true;
		}
		
		public static RelicInstance readBinary(BufferReference dat) {
			if(dat == null) return null;
			RelicInstance str = new RelicInstance();
			if(!str.readBinary_internal(dat)) return null;
			return str;
		}
		
		public static RelicInstance readXMLNode(Element xml_element) {
			if(xml_element == null) return null;
			RelicInstance str = new RelicInstance();
			if(!str.readXMLNode_internal(xml_element)) return null;
			return str;
		}
		
		public static RelicInstance readPropertyStream(BufferReference dat, boolean byteOrder, int verFieldSize) {
			if(dat == null) return null;
			MaxisPropertyStream stream = MaxisPropertyStream.openForRead(dat, byteOrder, verFieldSize);
			return readPropertyStream(stream);
		}
		
		public static RelicInstance readPropertyStream(MaxisPropertyStream stream) {
			if(stream == null) return null;
			RelicInstance str = new RelicInstance();
			if(!str.readPropertyStream_internal(stream));
			return str;
		}
		
		/*----- Write -----*/
		
		public int getBinarySize() {
			int size = baseSize;
			size += relicJournalData.getBinarySize();
			return size;
		}
		
		public FileBuffer writeBinary(boolean byteOrder) {
			FileBuffer buff = new FileBuffer(getBinarySize(), byteOrder);
			writeBinaryTo(buff);
			return buff;
		}
		
		public int writeBinaryTo(FileBuffer target) {
			if(target == null) return 0;
			long stPos = target.getFileSize();
			
			target.addToFile(relicGuidKey);
			relicJournalData.writeBinaryTo(target);

			return (int)(target.getFileSize() - stPos);
		}
	
		public void writeXMLNode(Writer out, String indent) throws IOException {
			writeXMLNode(out, indent, null);
		}
		
		public void writeXMLNode(Writer out, String indent, String varName) throws IOException {
			if(out == null) return;
			if(indent == null) indent = "";
			
			out.write(indent);
			out.write(String.format("<%s", xmlNodeName));
			if(varName != null){
				out.write(String.format(" VarName=\"%s\"", varName));
			}
			out.write(String.format(" %s=\"%s\"", XMLKEY_RELICGUIDKEY, CollectableRelicGuid.stringFromValue(relicGuidKey)));
			out.write(">\n");
			relicJournalData.writeXMLNode(out, indent + "\t", XMLKEY_RELICJOURNALDATA);
			out.write(indent);
			out.write(String.format("</%s>\n", xmlNodeName));

		}
	
		public void addToPropertyStream(MaxisPropertyStream ps) {	
			if(ps == null) return;
			boolean byte_order = ps.getByteOrder();
			int verFieldSize = ps.getVersionFieldSize();
			ps.addInt(relicGuidKey, psidBase, false);
			ps.addChildStream(relicJournalData.toPropertyStream(byte_order, verFieldSize), psidBase+1);
		}
	}

	/*----- Read -----*/
	
	protected boolean readBinary_internal(BufferReference dat) {
		if(dat == null) return false;
		
		mNumDigSitesExcavated = dat.nextInt();
		mMostValuableTrashRelic = dat.nextInt();
		mMostValuableCollectableRelic = dat.nextInt();
		mAgeOfOldestTrashRelic = dat.nextInt();
		mAgeOfOldestCollectableRelic = dat.nextInt();
		mNumTrashRelicsAnalyzed = dat.nextInt();
		mNumCollectableRelicsAnalyzed = dat.nextInt();
		mMoneyEarnedSellingTrashRelics = dat.nextInt();
		mMoneyEarnedSellingCollectableRelics = dat.nextInt();
		mNumberCollectionsCompleted = dat.nextInt();
		mHistoricalHoarderIsNew = MaxisTypes.readBinaryBool(dat);
		mRelicCollectionConnoisseurIsNew = MaxisTypes.readBinaryBool(dat);
		mNumTrashRelicsFoundPerCulture = new int[TRASH_RELICS_LEN];
		for(int i = 0; i < TRASH_RELICS_LEN; i++){
			mNumTrashRelicsFoundPerCulture[i] = dat.nextInt();
		}
		mNumCollectableRelicsFoundPerCulture = new int[COLL_RELICS_LEN];
		for(int i = 0; i < COLL_RELICS_LEN; i++){
			mNumCollectableRelicsFoundPerCulture[i] = dat.nextInt();
		}
		relicCollectionTypeMap = RelicCollectionTypeMap.readBinary(dat);
		mLifetimeOppsShown = new boolean[OPPS_LEN];
		for(int i = 0; i < OPPS_LEN; i++){
			mLifetimeOppsShown[i] = MaxisTypes.readBinaryBool(dat);
		}

		return true;
	}
	
	protected boolean readXMLNode_internal(Element xml_element) {
		if(xml_element == null) return false;
		String nn = xml_element.getNodeName();
		if(nn == null) return false;
		if(!nn.equals(xmlNodeName)) return false;
		
		String aval = null;
		Element child = null;
		aval = xml_element.getAttribute(XMLKEY_MNUMDIGSITESEXCAVATED);
		if(aval != null) mNumDigSitesExcavated = StringUtils.parseSignedInt(aval);
		aval = xml_element.getAttribute(XMLKEY_MMOSTVALUABLETRASHRELIC);
		if(aval != null) mMostValuableTrashRelic = StringUtils.parseSignedInt(aval);
		aval = xml_element.getAttribute(XMLKEY_MMOSTVALUABLECOLLECTABLERELIC);
		if(aval != null) mMostValuableCollectableRelic = StringUtils.parseSignedInt(aval);
		aval = xml_element.getAttribute(XMLKEY_MAGEOFOLDESTTRASHRELIC);
		if(aval != null) mAgeOfOldestTrashRelic = StringUtils.parseSignedInt(aval);
		aval = xml_element.getAttribute(XMLKEY_MAGEOFOLDESTCOLLECTABLERELIC);
		if(aval != null) mAgeOfOldestCollectableRelic = StringUtils.parseSignedInt(aval);
		aval = xml_element.getAttribute(XMLKEY_MNUMTRASHRELICSANALYZED);
		if(aval != null) mNumTrashRelicsAnalyzed = StringUtils.parseSignedInt(aval);
		aval = xml_element.getAttribute(XMLKEY_MNUMCOLLECTABLERELICSANALYZED);
		if(aval != null) mNumCollectableRelicsAnalyzed = StringUtils.parseSignedInt(aval);
		aval = xml_element.getAttribute(XMLKEY_MMONEYEARNEDSELLINGTRASHRELICS);
		if(aval != null) mMoneyEarnedSellingTrashRelics = StringUtils.parseSignedInt(aval);
		aval = xml_element.getAttribute(XMLKEY_MMONEYEARNEDSELLINGCOLLECTABLERELICS);
		if(aval != null) mMoneyEarnedSellingCollectableRelics = StringUtils.parseSignedInt(aval);
		aval = xml_element.getAttribute(XMLKEY_MNUMBERCOLLECTIONSCOMPLETED);
		if(aval != null) mNumberCollectionsCompleted = StringUtils.parseSignedInt(aval);
		aval = xml_element.getAttribute(XMLKEY_MHISTORICALHOARDERISNEW);
		if(aval != null) mHistoricalHoarderIsNew = Boolean.parseBoolean(aval);
		aval = xml_element.getAttribute(XMLKEY_MRELICCOLLECTIONCONNOISSEURISNEW);
		if(aval != null) mRelicCollectionConnoisseurIsNew = Boolean.parseBoolean(aval);
		child = XMLReader.getFirstChildElementWithTagAndAttribute(xml_element, "Array", "VarName", XMLKEY_MNUMTRASHRELICSFOUNDPERCULTURE);
		if(child != null){
			mNumTrashRelicsFoundPerCulture = new int[TRASH_RELICS_LEN];
			List<Element> gclist = XMLReader.getChildElementsWithTag(child, "ArrayMember");
			int i = 0;
			for(Element gc : gclist){
				aval = gc.getAttribute("Value");
				if(aval != null) mNumTrashRelicsFoundPerCulture[i] = StringUtils.parseSignedInt(aval);
				i++;
			}
		}
		child = XMLReader.getFirstChildElementWithTagAndAttribute(xml_element, "Array", "VarName", XMLKEY_MNUMCOLLECTABLERELICSFOUNDPERCULTURE);
		if(child != null){
			mNumCollectableRelicsFoundPerCulture = new int[COLL_RELICS_LEN];
			List<Element> gclist = XMLReader.getChildElementsWithTag(child, "ArrayMember");
			int i = 0;
			for(Element gc : gclist){
				aval = gc.getAttribute("Value");
				if(aval != null) mNumCollectableRelicsFoundPerCulture[i] = StringUtils.parseSignedInt(aval);
				i++;
			}
		}
		child = XMLReader.getFirstChildElementWithTagAndAttribute(xml_element, "RelicCollectionTypeMap", "VarName", XMLKEY_RELICCOLLECTIONTYPEMAP);
		if(child != null) relicCollectionTypeMap = RelicCollectionTypeMap.readXMLNode(child);
		child = XMLReader.getFirstChildElementWithTagAndAttribute(xml_element, "Array", "VarName", XMLKEY_MLIFETIMEOPPSSHOWN);
		if(child != null){
			mLifetimeOppsShown = new boolean[OPPS_LEN];
			List<Element> gclist = XMLReader.getChildElementsWithTag(child, "ArrayMember");
			int i = 0;
			for(Element gc : gclist){
				aval = gc.getAttribute("Value");
				if(aval != null) mLifetimeOppsShown[i] = Boolean.parseBoolean(aval);
				i++;
			}
		}

		return true;
	}
	
	protected boolean readPropertyStream_internal(MaxisPropertyStream stream) {
		if(stream == null) return false;
		
		mNumDigSitesExcavated = stream.getFieldAsInt(PSID_MNUMDIGSITESEXCAVATED, true);
		mMostValuableTrashRelic = stream.getFieldAsInt(PSID_MMOSTVALUABLETRASHRELIC, true);
		mMostValuableCollectableRelic = stream.getFieldAsInt(PSID_MMOSTVALUABLECOLLECTABLERELIC, true);
		mAgeOfOldestTrashRelic = stream.getFieldAsInt(PSID_MAGEOFOLDESTTRASHRELIC, true);
		mAgeOfOldestCollectableRelic = stream.getFieldAsInt(PSID_MAGEOFOLDESTCOLLECTABLERELIC, true);
		mNumTrashRelicsAnalyzed = stream.getFieldAsInt(PSID_MNUMTRASHRELICSANALYZED, true);
		mNumCollectableRelicsAnalyzed = stream.getFieldAsInt(PSID_MNUMCOLLECTABLERELICSANALYZED, true);
		mMoneyEarnedSellingTrashRelics = stream.getFieldAsInt(PSID_MMONEYEARNEDSELLINGTRASHRELICS, true);
		mMoneyEarnedSellingCollectableRelics = stream.getFieldAsInt(PSID_MMONEYEARNEDSELLINGCOLLECTABLERELICS, true);
		mNumberCollectionsCompleted = stream.getFieldAsInt(PSID_MNUMBERCOLLECTIONSCOMPLETED, true);
		mHistoricalHoarderIsNew = stream.getFieldAsBool(PSID_MHISTORICALHOARDERISNEW);
		mRelicCollectionConnoisseurIsNew = stream.getFieldAsBool(PSID_MRELICCOLLECTIONCONNOISSEURISNEW);
		mNumTrashRelicsFoundPerCulture = stream.getFieldAsIntArray(PSID_MNUMTRASHRELICSFOUNDPERCULTURE, true);
		mNumCollectableRelicsFoundPerCulture = stream.getFieldAsIntArray(PSID_MNUMCOLLECTABLERELICSFOUNDPERCULTURE, true);
		relicCollectionTypeMap = RelicCollectionTypeMap.readPropertyStream(stream.getChildStream(PSID_RELICCOLLECTIONTYPEMAP));
		mLifetimeOppsShown = stream.getFieldAsBoolArray(PSID_MLIFETIMEOPPSSHOWN);

		return true;
	}
	
	public static RelicStatTracking readBinary(BufferReference dat) {
		if(dat == null) return null;
		RelicStatTracking str = new RelicStatTracking();
		if(!str.readBinary_internal(dat)) return null;
		return str;
	}
	
	public static RelicStatTracking readXMLNode(Element xml_element) {
		if(xml_element == null) return null;
		RelicStatTracking str = new RelicStatTracking();
		if(!str.readXMLNode_internal(xml_element)) return null;
		return str;
	}
	
	public static RelicStatTracking readPropertyStream(BufferReference dat, boolean byteOrder, int verFieldSize) {
		if(dat == null) return null;
		MaxisPropertyStream stream = MaxisPropertyStream.openForRead(dat, byteOrder, verFieldSize);
		return readPropertyStream(stream);
	}
	
	public static RelicStatTracking readPropertyStream(MaxisPropertyStream stream) {
		if(stream == null) return null;
		RelicStatTracking str = new RelicStatTracking();
		if(!str.readPropertyStream_internal(stream));
		return str;
	}
	
	/*----- Write -----*/
	
	public int getBinarySize() {
		int size = baseSize;
		size += (mNumTrashRelicsFoundPerCulture.length * 4);
		size += (mNumCollectableRelicsFoundPerCulture.length * 4);
		size += relicCollectionTypeMap.getBinarySize();
		if(mLifetimeOppsShown != null){
			size += mLifetimeOppsShown.length;
		}
		return size;
	}
	
	public FileBuffer writeBinary(boolean byteOrder) {
		FileBuffer buff = new FileBuffer(getBinarySize(), byteOrder);
		writeBinaryTo(buff);
		return buff;
	}
	
	public int writeBinaryTo(FileBuffer target) {
		if(target == null) return 0;
		long stPos = target.getFileSize();
		
		target.addToFile(mNumDigSitesExcavated);
		target.addToFile(mMostValuableTrashRelic);
		target.addToFile(mMostValuableCollectableRelic);
		target.addToFile(mAgeOfOldestTrashRelic);
		target.addToFile(mAgeOfOldestCollectableRelic);
		target.addToFile(mNumTrashRelicsAnalyzed);
		target.addToFile(mNumCollectableRelicsAnalyzed);
		target.addToFile(mMoneyEarnedSellingTrashRelics);
		target.addToFile(mMoneyEarnedSellingCollectableRelics);
		target.addToFile(mNumberCollectionsCompleted);
		MaxisTypes.writeBinaryBool(target, mHistoricalHoarderIsNew);
		MaxisTypes.writeBinaryBool(target, mRelicCollectionConnoisseurIsNew);
		for(int i = 0; i < mNumTrashRelicsFoundPerCulture.length; i++){
			target.addToFile(mNumTrashRelicsFoundPerCulture[i]);
		}
		for(int i = 0; i < mNumCollectableRelicsFoundPerCulture.length; i++){
			target.addToFile(mNumCollectableRelicsFoundPerCulture[i]);
		}
		relicCollectionTypeMap.writeBinaryTo(target);
		for(int i = 0; i < mLifetimeOppsShown.length; i++){
			MaxisTypes.writeBinaryBool(target, mLifetimeOppsShown[i]);
		}

		return (int)(target.getFileSize() - stPos);
	}

	public void writeXMLNode(Writer out, String indent) throws IOException {
		writeXMLNode(out, indent, null);
	}
	
	public void writeXMLNode(Writer out, String indent, String varName) throws IOException {
		if(out == null) return;
		if(indent == null) indent = "";
		
		out.write(indent);
		out.write(String.format("<%s", xmlNodeName));
		if(varName != null){
			out.write(String.format(" VarName=\"%s\"", varName));
		}
		out.write(String.format(" %s=\"%d\"", XMLKEY_MNUMDIGSITESEXCAVATED, mNumDigSitesExcavated));
		out.write(String.format(" %s=\"%d\"", XMLKEY_MMOSTVALUABLETRASHRELIC, mMostValuableTrashRelic));
		out.write(String.format(" %s=\"%d\"", XMLKEY_MMOSTVALUABLECOLLECTABLERELIC, mMostValuableCollectableRelic));
		out.write(String.format(" %s=\"%d\"", XMLKEY_MAGEOFOLDESTTRASHRELIC, mAgeOfOldestTrashRelic));
		out.write(String.format(" %s=\"%d\"", XMLKEY_MAGEOFOLDESTCOLLECTABLERELIC, mAgeOfOldestCollectableRelic));
		out.write(String.format(" %s=\"%d\"", XMLKEY_MNUMTRASHRELICSANALYZED, mNumTrashRelicsAnalyzed));
		out.write(String.format(" %s=\"%d\"", XMLKEY_MNUMCOLLECTABLERELICSANALYZED, mNumCollectableRelicsAnalyzed));
		out.write(String.format(" %s=\"%d\"", XMLKEY_MMONEYEARNEDSELLINGTRASHRELICS, mMoneyEarnedSellingTrashRelics));
		out.write(String.format(" %s=\"%d\"", XMLKEY_MMONEYEARNEDSELLINGCOLLECTABLERELICS, mMoneyEarnedSellingCollectableRelics));
		out.write(String.format(" %s=\"%d\"", XMLKEY_MNUMBERCOLLECTIONSCOMPLETED, mNumberCollectionsCompleted));
		out.write(String.format(" %s=\"%b\"", XMLKEY_MHISTORICALHOARDERISNEW, mHistoricalHoarderIsNew));
		out.write(String.format(" %s=\"%b\"", XMLKEY_MRELICCOLLECTIONCONNOISSEURISNEW, mRelicCollectionConnoisseurIsNew));
		out.write(">\n");
		out.write(indent + String.format("\t<Array VarName=\"%s\">\n", XMLKEY_MNUMTRASHRELICSFOUNDPERCULTURE));
		for(int i = 0; i < mNumTrashRelicsFoundPerCulture.length; i++){
			out.write(indent + String.format("\t\t<ArrayMember Value=\"%d\"/>\n", mNumTrashRelicsFoundPerCulture[i]));
		}
		out.write(indent + "\t</Array>\n");
		out.write(indent + String.format("\t<Array VarName=\"%s\">\n", XMLKEY_MNUMCOLLECTABLERELICSFOUNDPERCULTURE));
		for(int i = 0; i < mNumCollectableRelicsFoundPerCulture.length; i++){
			out.write(indent + String.format("\t\t<ArrayMember Value=\"%d\"/>\n", mNumCollectableRelicsFoundPerCulture[i]));
		}
		out.write(indent + "\t</Array>\n");
		relicCollectionTypeMap.writeXMLNode(out, indent + "\t", XMLKEY_RELICCOLLECTIONTYPEMAP);
		if(mLifetimeOppsShown != null){
			out.write(indent + String.format("\t<Array VarName=\"%s\">\n", XMLKEY_MLIFETIMEOPPSSHOWN));
			for(int i = 0; i < mLifetimeOppsShown.length; i++){
				out.write(indent + String.format("\t\t<ArrayMember Value=\"%b\"/>\n", mLifetimeOppsShown[i]));
			}
			out.write(indent + "\t</Array>\n");
		}
		out.write(indent);
		out.write(String.format("</%s>\n", xmlNodeName));

	}

	public void addToPropertyStream(MaxisPropertyStream ps) {	
		if(ps == null) return;
		boolean byte_order = ps.getByteOrder();
		int verFieldSize = ps.getVersionFieldSize();
		
		ps.addInt(mNumDigSitesExcavated, PSID_MNUMDIGSITESEXCAVATED, true);
		ps.addInt(mMostValuableTrashRelic, PSID_MMOSTVALUABLETRASHRELIC, true);
		ps.addInt(mMostValuableCollectableRelic, PSID_MMOSTVALUABLECOLLECTABLERELIC, true);
		ps.addInt(mAgeOfOldestTrashRelic, PSID_MAGEOFOLDESTTRASHRELIC, true);
		ps.addInt(mAgeOfOldestCollectableRelic, PSID_MAGEOFOLDESTCOLLECTABLERELIC, true);
		ps.addInt(mNumTrashRelicsAnalyzed, PSID_MNUMTRASHRELICSANALYZED, true);
		ps.addInt(mNumCollectableRelicsAnalyzed, PSID_MNUMCOLLECTABLERELICSANALYZED, true);
		ps.addInt(mMoneyEarnedSellingTrashRelics, PSID_MMONEYEARNEDSELLINGTRASHRELICS, true);
		ps.addInt(mMoneyEarnedSellingCollectableRelics, PSID_MMONEYEARNEDSELLINGCOLLECTABLERELICS, true);
		ps.addInt(mNumberCollectionsCompleted, PSID_MNUMBERCOLLECTIONSCOMPLETED, true);
		ps.addBool(mHistoricalHoarderIsNew, PSID_MHISTORICALHOARDERISNEW);
		ps.addBool(mRelicCollectionConnoisseurIsNew, PSID_MRELICCOLLECTIONCONNOISSEURISNEW);
		ps.addIntArray(mNumTrashRelicsFoundPerCulture, PSID_MNUMTRASHRELICSFOUNDPERCULTURE, true);
		ps.addIntArray(mNumCollectableRelicsFoundPerCulture, PSID_MNUMCOLLECTABLERELICSFOUNDPERCULTURE, true);
		ps.addChildStream(relicCollectionTypeMap.toPropertyStream(byte_order, verFieldSize), PSID_RELICCOLLECTIONTYPEMAP);
		ps.addBoolArray(mLifetimeOppsShown, PSID_MLIFETIMEOPPSSHOWN);
	}
	
}
