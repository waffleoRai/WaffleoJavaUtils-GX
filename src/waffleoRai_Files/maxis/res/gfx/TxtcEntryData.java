/*-----------------------------------------------------
 * Autogenerated Java class from XML definition.
 * Created Sat, 18 Jan 2025 21:14:54 -0600
 *-----------------------------------------------------*/

package waffleoRai_Files.maxis.res.gfx;

import java.io.IOException;
import java.io.Writer;
import java.util.List;
import java.util.Map;

import org.w3c.dom.Element;

import waffleoRai_Containers.maxis.MaxisResKey;
import waffleoRai_Files.maxis.MaxisResRef;
import waffleoRai_Files.maxis.ts3enum.gfx.ColorChannelMask;
import waffleoRai_Files.maxis.ts3enum.gfx.TxtcBlendFactors;
import waffleoRai_Files.maxis.ts3enum.gfx.TxtcDataTypes;
import waffleoRai_Files.maxis.ts3enum.gfx.TxtcProperties;
import waffleoRai_Files.maxis.ts3enum.gfx.TxtcRenderTargets;
import waffleoRai_Files.maxis.ts3enum.gfx.TxtcShaderModels;
import waffleoRai_Files.maxis.ts3enum.gfx.TxtcStepTypes;
import waffleoRai_Utils.BufferReference;
import waffleoRai_Utils.FileBuffer;
import waffleoRai_Utils.StringUtils;

public class TxtcEntryData{
	
	public static FileBuffer readBinData(BufferReference ref, int dataType) {
		if(ref == null) return null;
		
		int datSize = 0;
		switch(dataType) {
		case TxtcDataTypes.D_Bool:
		case TxtcDataTypes.D_S8:
		case TxtcDataTypes.D_U8:
		case TxtcDataTypes.D_TGIIndex:
			datSize = 1;
			break;
		case TxtcDataTypes.D_S16:
		case TxtcDataTypes.D_U16:
			datSize = 2;
			break;
		case TxtcDataTypes.D_S32:
		case TxtcDataTypes.D_U32:
		case TxtcDataTypes.D_F32:
			datSize = 4;
			break;
		case TxtcDataTypes.D_S64:
		case TxtcDataTypes.D_U64:
			datSize = 8;
			break;
		case TxtcDataTypes.D_RectFloat:
		case TxtcDataTypes.D_FVec4:
			datSize = 16; //4 floats
			break;
		case TxtcDataTypes.D_String:
			short strlen = ref.getShort();
			datSize = strlen + 2; //TODO Not sure if that's the case? I'm assuming it's ASCII?
			break;
		}
		
		if(datSize < 1) return null;
		
		FileBuffer buff = new FileBuffer(datSize, ref.getBuffer().isBigEndian());
		for(int i = 0; i < datSize; i++) buff.addToFile(ref.nextByte());
		return buff;
	}
	
	public static FileBuffer readDataFromXml(Element node, int propId, int dataType, Map<String, Integer> refIndexMap) {
		if(node == null) return null;
		
		FileBuffer buff = null;
		String aval = node.getAttribute("Value");
		switch(propId) {
		case TxtcProperties.DestinationBlend:
		case TxtcProperties.SourceBlend:
			buff = new FileBuffer(4, false);
			buff.addToFile(TxtcBlendFactors.valueFromString(aval));
			break;
		case TxtcProperties.SkipShaderModel:
			buff = new FileBuffer(4, false);
			buff.addToFile(TxtcShaderModels.valueFromString(aval));
			break;
		case TxtcProperties.ColorWrite:
			buff = new FileBuffer(4, false);
			buff.addToFile(ColorChannelMask.valueFromString(aval));
			break;
		case TxtcProperties.Id:
			buff = new FileBuffer(4, false);
			buff.addToFile(TxtcStepTypes.valueFromString(aval));
			break;
		case TxtcProperties.ImageSource:
		case TxtcProperties.RenderTarget:
			buff = new FileBuffer(4, false);
			buff.addToFile(TxtcRenderTargets.valueFromString(aval));
			break;
		default:
			switch(dataType) {
			case TxtcDataTypes.D_Bool:
				buff = new FileBuffer(1, false);
				if(Boolean.parseBoolean(aval)) buff.addToFile((byte)1);
				else buff.addToFile((byte)0);
				break;
			case TxtcDataTypes.D_S8:
				buff = new FileBuffer(1, false);
				buff.addToFile((byte)StringUtils.parseSignedInt(aval));
				break;
			case TxtcDataTypes.D_U8:
				buff = new FileBuffer(1, false);
				buff.addToFile((byte)StringUtils.parseUnsignedInt(aval));
				break;
			case TxtcDataTypes.D_S16:
				buff = new FileBuffer(2, false);
				buff.addToFile((short)StringUtils.parseSignedInt(aval));
				break;
			case TxtcDataTypes.D_U16:
				buff = new FileBuffer(2, false);
				buff.addToFile((short)StringUtils.parseUnsignedInt(aval));
				break;
			case TxtcDataTypes.D_S32:
				buff = new FileBuffer(4, false);
				buff.addToFile(StringUtils.parseSignedInt(aval));
				break;
			case TxtcDataTypes.D_U32:
				buff = new FileBuffer(4, false);
				buff.addToFile(StringUtils.parseUnsignedInt(aval));
				break;
			case TxtcDataTypes.D_S64:
				buff = new FileBuffer(8, false);
				buff.addToFile(StringUtils.parseSignedLong(aval));
				break;
			case TxtcDataTypes.D_U64:
				buff = new FileBuffer(8, false);
				buff.addToFile(StringUtils.parseUnsignedLong(aval));
				break;
			case TxtcDataTypes.D_F32:
				buff = new FileBuffer(4, false);
				buff.addToFile(Float.floatToRawIntBits((float)Double.parseDouble(aval)));
				break;
			case TxtcDataTypes.D_RectFloat:
			case TxtcDataTypes.D_FVec4:
				buff = new FileBuffer(16, false);
				aval = aval.replace("{", "");
				aval = aval.replace("}", "");
				String[] spl = aval.split(",");
				for(int i = 0; i < 4; i++) {
					float f = 0f;
					if(i < spl.length) {
						f = (float)Double.parseDouble(spl[i].trim());
					}
					buff.addToFile(Float.floatToRawIntBits(f));
				}
				break;
			case TxtcDataTypes.D_String:
				//TODO Again not sure how this is formatted in binary
				int strlen = aval.length();
				buff = new FileBuffer(strlen + 2, false);
				buff.addToFile((short)strlen);
				buff.printASCIIToFile(aval);
				break;
			case TxtcDataTypes.D_TGIIndex:
				buff = new FileBuffer(1, false);
				if(refIndexMap != null) {
					Integer n = refIndexMap.get(aval);
					if(n == null) n = -1; //Should probably error or somefin. Eh.
					int nn = n;
					buff.addToFile((byte)nn);
				}
				else buff.addToFile((byte)StringUtils.parseSignedInt(aval));
				break;
			}
			break;
		}
		
		return buff;
	}
	
	public static void writeDataToXmlAttr(Writer out, int propId, int dataType, FileBuffer data, List<MaxisResRef> refTable) throws IOException {
		if(data == null || out == null) return;
		
		out.write(" Value=\"");
		switch(dataType) {
		case TxtcDataTypes.D_Bool:
			out.write(String.format("%b", data.getByte(0L) != 0));
			break;
		case TxtcDataTypes.D_S8:
			out.write(String.format("%d", data.getByte(0L)));
			break;
		case TxtcDataTypes.D_U8:
			out.write(String.format("0x%02x", data.getByte(0L)));
			break;
		case TxtcDataTypes.D_S16:
			out.write(String.format("%d", data.shortFromFile(0L)));
			break;
		case TxtcDataTypes.D_U16:
			out.write(String.format("0x%04x", data.shortFromFile(0L)));
			break;
		case TxtcDataTypes.D_S32:
			switch(propId) {
			case TxtcProperties.DestinationBlend:
			case TxtcProperties.SourceBlend:
				out.write(TxtcBlendFactors.stringFromValue(data.intFromFile(0L)));
				break;
			case TxtcProperties.SkipShaderModel:
				out.write(TxtcShaderModels.stringFromValue(data.intFromFile(0L)));
				break;
			case TxtcProperties.ColorWrite:
				out.write(ColorChannelMask.stringFromValue(data.intFromFile(0L)));
				break;
			default:
				out.write(String.format("%d", data.intFromFile(0L)));
				break;
			}
			break;
		case TxtcDataTypes.D_U32:
			switch(propId) {
			case TxtcProperties.Id:
				out.write(TxtcStepTypes.stringFromValue(data.intFromFile(0L)));
				break;
			case TxtcProperties.ImageSource:
			case TxtcProperties.RenderTarget:
				out.write(TxtcRenderTargets.stringFromValue(data.intFromFile(0L)));
				break;
			default:
				out.write(String.format("0x%08x", data.intFromFile(0L)));
				break;
			}
			break;
		case TxtcDataTypes.D_F32:
			out.write(String.format("%.4f", Float.intBitsToFloat(data.intFromFile(0L))));
			break;
		case TxtcDataTypes.D_S64:
			out.write(String.format("%d", data.longFromFile(0L)));
			break;
		case TxtcDataTypes.D_U64:
			out.write(String.format("0x%016x", data.longFromFile(0L)));
			break;
		case TxtcDataTypes.D_RectFloat:
		case TxtcDataTypes.D_FVec4:
			out.write("{");
			for(int i = 0; i < 4; i++) {
				float f = Float.intBitsToFloat(data.intFromFile(i << 2));
				if(i > 0) out.write(",");
				out.write(String.format("%.4f", f));
			}
			out.write("}");
			break;
		case TxtcDataTypes.D_String:
			//TODO Again not sure how this is formatted in binary
			int strlen = Short.toUnsignedInt(data.shortFromFile(0L));
			String asciistr = data.getASCII_string(2L, strlen);
			out.write(asciistr);
			break;
		case TxtcDataTypes.D_TGIIndex:
			if(refTable != null) {
				int index = Byte.toUnsignedInt(data.getByte(0L));
				if((index >= 0) && (index < refTable.size())) {
					MaxisResRef ref = refTable.get(index);
					String uname = ref.getUniqueName();
					if(uname != null) out.write(uname);
					else {
						MaxisResKey key = ref.getKey();
						key.writeXMLValue(out);
					}
				}
				else out.write(String.format("%d", data.getByte(0L)));
			}
			else out.write(String.format("%d", data.getByte(0L)));
			break;
		}
		out.write("\"");
		
	}

}
