/*-----------------------------------------------------
 * Autogenerated Java class from XML definition.
 * Created Sat, 18 Jan 2025 21:14:54 -0600
 *-----------------------------------------------------*/

package waffleoRai_Files.maxis.res.gfx;

import java.io.BufferedWriter;
import java.io.FileWriter;
import java.io.IOException;
import java.io.Writer;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;

import org.w3c.dom.Document;
import org.w3c.dom.Element;
import org.w3c.dom.Node;
import org.w3c.dom.NodeList;

import waffleoRai_Containers.maxis.MaxisResKey;
import waffleoRai_Containers.maxis.MaxisResTable;
import waffleoRai_Files.XMLReader;
import waffleoRai_Files.maxis.MaxisResRef;
import waffleoRai_Files.maxis.ts3enum.cas.CASPartType;
import waffleoRai_Files.maxis.ts3enum.gfx.PatternSize;
import waffleoRai_Files.maxis.ts3enum.gfx.TxtcDataTypes;
import waffleoRai_Files.maxis.ts3enum.gfx.TxtcProperties;
import waffleoRai_Utils.BufferReference;
import waffleoRai_Utils.FileBuffer;
import waffleoRai_Utils.StringUtils;

public class TextureCompositor{
	
	public static final int DEFO_WRITE_VERSION = 8;

	//private static final String XMLKEY_FILEVERSION = "FileVersion";
	//private static final String XMLKEY_TGIOFFSET = "TgiOffset";
	//private static final String XMLKEY_EMBEDCOUNT = "EmbedCount";
	private static final String XMLKEY_EMBEDLIST = "EmbedList";
	private static final String XMLKEY_PATTERNSIZE = "PatternSize";
	private static final String XMLKEY_PARTTYPE = "PartType";
	private static final String XMLKEY_RESERVEDA = "ReservedA";
	//private static final String XMLKEY_ENTRYCOUNT = "EntryCount";
	private static final String XMLKEY_RESERVEDB = "ReservedB";
	private static final String XMLKEY_ENTRYLIST = "EntryList";
	//private static final String XMLKEY_TGICOUNT = "TgiCount";
	private static final String XMLKEY_TGITABLE = "TgiTable";
	
	private static final String XML_NODE_NAME = "TextureCompositor";
	private static final int BASE_BIN_SIZE = 22;

	//public int fileVersion;
	//public int tgiOffset;
	//public byte embedCount;
	public ArrayList<EmbeddedTxtc> embedList = new ArrayList<EmbeddedTxtc>();
	public int patternSize;
	public int partType;
	public byte reservedA;
	//public int entryCount;
	public byte reservedB;
	public ArrayList<TxtcEntry> entryList = new ArrayList<TxtcEntry>();
	//public byte tgiCount;
	public ArrayList<MaxisResRef> tgiTable = new ArrayList<MaxisResRef>();

	public TextureCompositor() {}
	
	/*----- Inner Classes -----*/

	public static class EmbeddedTxtc{

		private static final String XMLKEY_TGITBLINDEX = "TgiTblIndex";
		//private static final String XMLKEY_TXTCSIZE = "TxtcSize";
		private static final String XMLKEY_TXTCDATA = "TxtcData";
		private static final String XMLKEY_UNK3 = "Unk3";
		
		private static final String XML_NODE_NAME = "EmbeddedTxtc";
		private static final int BASE_BIN_SIZE = 5;

		public byte tgiTblIndex;
		public int txtcSize;
		public TextureCompositor txtcData;
		public byte[] unk3 = new byte[3];
		
		public EmbeddedTxtc() {}
		
		/*----- Read -----*/
		
		protected boolean readBinary_internal(BufferReference dat) {
			if(dat == null) return false;
			
			tgiTblIndex = dat.nextByte();
			txtcSize = dat.nextInt();
			txtcData = TextureCompositor.readBinary(dat);
			for(int i = 0; i < 3; i++){
				unk3[i] = dat.nextByte();
			}

			return true;
		}
		
		protected boolean readXMLNode_internal(Element xml_element, Map<String, Integer> refIndexMap) {
			if(xml_element == null) return false;
			String nn = xml_element.getNodeName();
			if(nn == null) return false;
			if(!nn.equals(XML_NODE_NAME)) return false;
			
			String aval = null;
			Element child = null;
			aval = xml_element.getAttribute("Reference");
			if((aval != null) && !aval.isEmpty()) {
				if(refIndexMap != null) {
					Integer n = refIndexMap.get(aval);
					if(n != null) tgiTblIndex = (byte)((int)n);
					else tgiTblIndex = (byte)StringUtils.parseUnsignedInt(aval);
				}
				else tgiTblIndex = (byte)StringUtils.parseUnsignedInt(aval);
			}
			else {
				aval = xml_element.getAttribute(XMLKEY_TGITBLINDEX);
				if((aval != null) && !aval.isEmpty()) {
					if(refIndexMap != null) {
						Integer n = refIndexMap.get(aval);
						if(n != null) tgiTblIndex = (byte)((int)n);
						else tgiTblIndex = (byte)StringUtils.parseUnsignedInt(aval);
					}
					else tgiTblIndex = (byte)StringUtils.parseUnsignedInt(aval);
				}
			}
			
			//aval = xml_element.getAttribute(XMLKEY_TXTCSIZE);
			//if(aval != null) txtcSize = StringUtils.parseUnsignedInt(aval);
			child = XMLReader.getFirstChildElementWithTagAndAttribute(xml_element, "TextureCompositor", "VarName", XMLKEY_TXTCDATA);
			if(child != null) txtcData = TextureCompositor.readXMLNode(child, refIndexMap);
			
			aval = xml_element.getAttribute(XMLKEY_UNK3);
			if((aval != null) && !aval.isEmpty()) {
				aval = aval.replace("{", "");
				aval = aval.replace("}", "");
				String[] spl = aval.split(",");
				for(int i = 0; i < 3; i++) {
					if(i >= spl.length) break;
					unk3[i] = (byte)StringUtils.parseUnsignedInt(spl[i].trim());
				}
			}
			
			return true;
		}
		
		public static EmbeddedTxtc readBinary(BufferReference dat) {
			if(dat == null) return null;
			EmbeddedTxtc str = new EmbeddedTxtc();
			if(!str.readBinary_internal(dat)) return null;
			return str;
		}
		
		public static EmbeddedTxtc readXMLNode(Element xml_element, Map<String, Integer> refIndexMap) {
			if(xml_element == null) return null;
			EmbeddedTxtc str = new EmbeddedTxtc();
			if(!str.readXMLNode_internal(xml_element, refIndexMap)) return null;
			return str;
		}
		
		/*----- Write -----*/
		
		public int getBinarySize(int fileVersion) {
			int size = BASE_BIN_SIZE;
			size += txtcData.getBinarySize(fileVersion);
			size += unk3.length;
			return size;
		}
		
		public FileBuffer writeBinary(boolean byteOrder, int fileVersion) {
			FileBuffer buff = new FileBuffer(getBinarySize(fileVersion), byteOrder);
			writeBinaryTo(buff, fileVersion);
			return buff;
		}
		
		public int writeBinaryTo(FileBuffer target, int fileVersion) {
			if(target == null) return 0;
			long stPos = target.getFileSize();
			
			target.addToFile(tgiTblIndex);
			target.addToFile(txtcData.getBinarySize(fileVersion) + 3);
			txtcData.writeBinaryTo(target, fileVersion);
			for(int i = 0; i < 3; i++){
				target.addToFile(unk3[i]);
			}

			return (int)(target.getFileSize() - stPos);
		}
	
		public void writeXMLNode(Writer out, String indent, List<MaxisResRef> refTable) throws IOException {
			writeXMLNode(out, indent, null, refTable);
		}
		
		public void writeXMLNode(Writer out, String indent, String varName, List<MaxisResRef> refTable) throws IOException {
			if(out == null) return;
			if(indent == null) indent = "";
			
			out.write(indent);
			out.write(String.format("<%s", XML_NODE_NAME));
			if(varName != null){
				out.write(String.format(" VarName=\"%s\"", varName));
			}
			
			if(refTable != null) {
				if((tgiTblIndex >= 0) && (tgiTblIndex < refTable.size())) {
					MaxisResRef resRef = refTable.get(tgiTblIndex);
					String rstr = resRef.getUniqueName();
					if(rstr == null) rstr = resRef.getKey().genXMLValue();
					out.write(String.format(" %s=\"%s\"", "Reference", rstr));
				}
				else out.write(String.format(" %s=\"%d\"", XMLKEY_TGITBLINDEX, tgiTblIndex));
			}
			else out.write(String.format(" %s=\"%d\"", XMLKEY_TGITBLINDEX, tgiTblIndex));
			//out.write(String.format(" %s=\"0x%08x\"", XMLKEY_TXTCSIZE, txtcSize));
			out.write(String.format(" %s=\"{", XMLKEY_UNK3));
			for(int i = 0; i < 3; i++) {
				if(i > 0) out.write(",");
				out.write(String.format("0x%02x", unk3[i]));
			}
			out.write("}\"");
			out.write(">\n");
			txtcData.writeXMLNode(out, indent + "\t", XMLKEY_TXTCDATA, refTable);
			
			out.write(indent);
			out.write(String.format("</%s>\n", XML_NODE_NAME));
		}
	
	}

	public static class TxtcEntry{
		//Each entry is just a list of properties
		private static final String XML_NODE_NAME = "TxtcEntry";
		
		public List<TxtcEntryProperty> properties = new LinkedList<TxtcEntryProperty>();
		
		/*----- Read -----*/
		
		protected boolean readBinary_internal(BufferReference dat) {
			if(dat == null) return false;

			TxtcEntryProperty prop = TxtcEntryProperty.readBinary(dat);
			while(prop != null) {
				properties.add(prop);
				prop = TxtcEntryProperty.readBinary(dat);
			}

			return true;
		}
		
		protected boolean readXMLNode_internal(Element xml_element, Map<String, Integer> refIndexMap) {
			if(xml_element == null) return false;
			String nn = xml_element.getNodeName();
			if(nn == null) return false;
			if(!nn.equals(XML_NODE_NAME)) return false;
			
			List<Element> propNodes = XMLReader.getChildElementsWithTag(xml_element, TxtcEntryProperty.XML_NODE_NAME);
			for(Element child : propNodes) {
				TxtcEntryProperty property = TxtcEntryProperty.readXMLNode(child, refIndexMap);
				properties.add(property);
			}
			
			return true;
		}
		
		public static TxtcEntry readBinary(BufferReference dat) {
			if(dat == null) return null;
			TxtcEntry str = new TxtcEntry();
			if(!str.readBinary_internal(dat)) return null;
			return str;
		}
		
		public static TxtcEntry readXMLNode(Element xml_element, Map<String, Integer> refIndexMap) {
			if(xml_element == null) return null;
			TxtcEntry str = new TxtcEntry();
			if(!str.readXMLNode_internal(xml_element, refIndexMap)) return null;
			return str;
		}
		
		/*----- Write -----*/
		
		public int getBinarySize() {
			int size = 4; //End
			for(TxtcEntryProperty prop : properties) {
				size += prop.getBinarySize();
			}
			return size;
		}
		
		public FileBuffer writeBinary(boolean byteOrder) {
			FileBuffer buff = new FileBuffer(getBinarySize(), byteOrder);
			writeBinaryTo(buff);
			return buff;
		}
		
		public int writeBinaryTo(FileBuffer target) {
			if(target == null) return 0;
			long stPos = target.getFileSize();
			
			for(TxtcEntryProperty prop : properties) {
				prop.writeBinaryTo(target);
			}
			
			target.addToFile(0); //End
			return (int)(target.getFileSize() - stPos);
		}
		
		public void writeXMLNode(Writer out, String indent, List<MaxisResRef> refTable) throws IOException {
			writeXMLNode(out, indent, null, refTable);
		}
		
		public void writeXMLNode(Writer out, String indent, String varName, List<MaxisResRef> refTable) throws IOException {
			if(out == null) return;
			if(indent == null) indent = "";
			
			out.write(indent);
			out.write(String.format("<%s", XML_NODE_NAME));
			if(varName != null){
				out.write(String.format(" VarName=\"%s\"", varName));
			}
			out.write(">\n");
			
			for(TxtcEntryProperty prop : properties) {
				prop.writeXMLNode(out, indent + "\t", null, refTable);
			}
			
			out.write(indent + "</" + XML_NODE_NAME + ">\n");
		}
		
	}
	
	public static class TxtcEntryProperty{

		private static final String XMLKEY_PROPERTYID = "PropertyId";
		private static final String XMLKEY_RESERVEDC = "ReservedC";
		private static final String XMLKEY_DATATYPE = "DataType";
		//private static final String XMLKEY_DATA = "Data";
		
		private static final String XML_NODE_NAME = "TxtcEntryProperty";
		private static final int BASE_BIN_SIZE = 6;

		public int propertyId;
		public byte reservedC;
		public byte dataType;
		//public TxtcEntryData data;
		public FileBuffer data;
	
		public TxtcEntryProperty() {}
		
		/*----- Read -----*/
		
		protected boolean readBinary_internal(BufferReference dat) {
			if(dat == null) return false;
			
			propertyId = dat.nextInt();
			if(propertyId == 0) return false; //End of list
			
			reservedC = dat.nextByte();
			dataType = dat.nextByte();
			//data = TxtcEntryData.readBinary(dat);
			data = TxtcEntryData.readBinData(dat, dataType);

			return true;
		}
		
		protected boolean readXMLNode_internal(Element xml_element, Map<String, Integer> refIndexMap) {
			if(xml_element == null) return false;
			String nn = xml_element.getNodeName();
			if(nn == null) return false;
			if(!nn.equals(XML_NODE_NAME)) return false;
			
			String aval = null;
			aval = xml_element.getAttribute(XMLKEY_PROPERTYID);
			if((aval != null) && !aval.isEmpty()) propertyId = TxtcProperties.valueFromString(aval);
			aval = xml_element.getAttribute(XMLKEY_RESERVEDC);
			if((aval != null) && !aval.isEmpty()) reservedC = (byte)StringUtils.parseUnsignedInt(aval);
			aval = xml_element.getAttribute(XMLKEY_DATATYPE);
			if((aval != null) && !aval.isEmpty()) dataType = TxtcDataTypes.valueFromString(aval);
			
			data = TxtcEntryData.readDataFromXml(xml_element, propertyId, dataType, refIndexMap);

			return true;
		}
		
		public static TxtcEntryProperty readBinary(BufferReference dat) {
			if(dat == null) return null;
			TxtcEntryProperty str = new TxtcEntryProperty();
			if(!str.readBinary_internal(dat)) return null;
			return str;
		}
		
		public static TxtcEntryProperty readXMLNode(Element xml_element, Map<String, Integer> refIndexMap) {
			if(xml_element == null) return null;
			TxtcEntryProperty str = new TxtcEntryProperty();
			if(!str.readXMLNode_internal(xml_element, refIndexMap)) return null;
			return str;
		}
		
		/*----- Write -----*/
		
		public int getBinarySize() {
			int size = BASE_BIN_SIZE;
			size += (int)data.getFileSize();
			return size;
		}
		
		public FileBuffer writeBinary(boolean byteOrder) {
			FileBuffer buff = new FileBuffer(getBinarySize(), byteOrder);
			writeBinaryTo(buff);
			return buff;
		}
		
		public int writeBinaryTo(FileBuffer target) {
			if(target == null) return 0;
			long stPos = target.getFileSize();
			
			target.addToFile(propertyId);
			target.addToFile(reservedC);
			target.addToFile(dataType);
			target.addToFile(data);
			//data.writeBinaryTo(target);

			return (int)(target.getFileSize() - stPos);
		}
	
		public void writeXMLNode(Writer out, String indent, List<MaxisResRef> refTable) throws IOException {
			writeXMLNode(out, indent, null, refTable);
		}
		
		public void writeXMLNode(Writer out, String indent, String varName, List<MaxisResRef> refTable) throws IOException {
			if(out == null) return;
			if(indent == null) indent = "";
			
			out.write(indent);
			out.write(String.format("<%s", XML_NODE_NAME));
			if(varName != null){
				out.write(String.format(" VarName=\"%s\"", varName));
			}
			out.write(String.format(" %s=\"%s\"", XMLKEY_PROPERTYID, TxtcProperties.stringFromValue(propertyId)));
			//out.write(String.format(" %s=\"0x%02x\"", XMLKEY_RESERVEDC, reservedC));
			out.write(String.format(" %s=\"%s\"", XMLKEY_DATATYPE, TxtcDataTypes.stringFromValue(dataType)));
			TxtcEntryData.writeDataToXmlAttr(out, propertyId, dataType, data, refTable);
			out.write("/>\n");
		}
	
	}
	
	/*----- Setters -----*/
	
	public void linkReferences(MaxisResTable refTable) {
		if(refTable == null) return;
		ArrayList<MaxisResRef> oldTable = tgiTable;
		tgiTable = new ArrayList<MaxisResRef>(oldTable.size()+1);
		
		for(MaxisResRef ref : oldTable) {
			MaxisResRef addref = refTable.getEntry(ref.getKey());
			if(addref == null) ref = addref;
			tgiTable.add(addref);
		}
	}

	/*----- Read -----*/
	
	protected boolean readBinary_internal(BufferReference dat) {
		if(dat == null) return false;
		
		int fileVersion = dat.nextInt();
		dat.add(4L); //tgiOffset = dat.nextInt();
		if (fileVersion >= 7){
			int embedCount = Byte.toUnsignedInt(dat.nextByte());
			if(embedCount > 0) {
				embedList.ensureCapacity(embedCount);
				for(int i = 0; i < embedCount; i++){
					EmbeddedTxtc embedtxt = EmbeddedTxtc.readBinary(dat);
					if(embedtxt != null) embedList.add(embedtxt);
				}	
			}
		}
		
		patternSize = dat.nextInt();
		partType = dat.nextInt();
		reservedA = dat.nextByte();
		int entryCount = dat.nextInt();
		if (fileVersion >= 8) reservedB = dat.nextByte();
		else reservedB = 0;
		entryList.ensureCapacity(entryCount);
		for(int i = 0; i < entryCount; i++){
			TxtcEntry entry = TxtcEntry.readBinary(dat);
			if(entry != null) entryList.add(entry);
		}
		
		int tgiCount = Byte.toUnsignedInt(dat.nextByte());
		tgiTable.ensureCapacity(tgiCount);
		for(int i = 0; i < tgiCount; i++){
			MaxisResKey resourceKey = MaxisResKey.readBinIGT(dat);
			if(resourceKey != null) tgiTable.add(new MaxisResRef(resourceKey));
		}

		return true;
	}
	
	protected boolean readXMLNode_internal(Element xml_element, Map<String, Integer> parentRefIndexMap) {
		if(xml_element == null) return false;
		String nn = xml_element.getNodeName();
		if(nn == null) return false;
		if(!nn.equals(XML_NODE_NAME)) return false;
		
		String aval = null;
		Element child = null;
		
		aval = xml_element.getAttribute(XMLKEY_PATTERNSIZE);
		if((aval != null) && !aval.isEmpty()) patternSize = PatternSize.valueFromString(aval);
		aval = xml_element.getAttribute(XMLKEY_PARTTYPE);
		if((aval != null) && !aval.isEmpty()) partType = CASPartType.valueFromString(aval);
		aval = xml_element.getAttribute(XMLKEY_RESERVEDA);
		if((aval != null) && !aval.isEmpty()) reservedA = (byte)StringUtils.parseUnsignedInt(aval);
		aval = xml_element.getAttribute(XMLKEY_RESERVEDB);
		if((aval != null) && !aval.isEmpty()) reservedB = (byte)StringUtils.parseUnsignedInt(aval);
		
		Map<String, Integer> refNameMap = new HashMap<String, Integer>();
		child = XMLReader.getFirstChildElementWithTagAndAttribute(xml_element, "List", "VarName", XMLKEY_TGITABLE);
		if(child != null){
			List<Element> gclist = XMLReader.getChildElementsWithTag(child, "MaxisResReference");
			int tgiCount = gclist.size();
			if(tgiCount > 0) {
				tgiTable.ensureCapacity(tgiCount);
				for(Element gc : gclist){
					tgiTable.add(MaxisResRef.fromXMLNode(gc));
				}	
			}
		}
		
		int i = 0;
		if(!tgiTable.isEmpty()) {
			for(MaxisResRef ref : tgiTable) {
				String u = ref.getUniqueName();
				if(u != null) {
					refNameMap.put(u, i);
				}
				MaxisResKey key = ref.getKey();
				refNameMap.put(key.genXMLValue(), i);
				i++;
			}	
		}
		else refNameMap = parentRefIndexMap;
		
		child = XMLReader.getFirstChildElementWithTagAndAttribute(xml_element, "List", "VarName", XMLKEY_ENTRYLIST);
		if(child != null){
			List<Element> gclist = XMLReader.getChildElementsWithTag(child, "TxtcEntry");
			int entryCount = gclist.size();
			if(entryCount > 0) {
				entryList.ensureCapacity(entryCount);
				for(Element gc : gclist){
					entryList.add(TxtcEntry.readXMLNode(gc, refNameMap));
				}	
			}
		}
		
		child = XMLReader.getFirstChildElementWithTagAndAttribute(xml_element, "List", "VarName", XMLKEY_EMBEDLIST);
		if(child != null){
			List<Element> gclist = XMLReader.getChildElementsWithTag(child, "EmbeddedTxtc");
			int embedCount = gclist.size();
			if(embedCount > 0) {
				embedList.ensureCapacity(embedCount);
				for(Element gc : gclist){
					embedList.add(EmbeddedTxtc.readXMLNode(gc, refNameMap));
				}	
			}
		}

		return true;
	}
	
	public static TextureCompositor readBinary(BufferReference dat) {
		if(dat == null) return null;
		TextureCompositor str = new TextureCompositor();
		if(!str.readBinary_internal(dat)) return null;
		return str;
	}
	
	public static TextureCompositor readXMLNode(Element xml_element, Map<String, Integer> parentRefIndexMap) {
		if(xml_element == null) return null;
		TextureCompositor str = new TextureCompositor();
		if(!str.readXMLNode_internal(xml_element, parentRefIndexMap)) return null;
		return str;
	}
	
	/*----- Write -----*/
	
	public int getBinarySize(int version) {
		int size = BASE_BIN_SIZE;
		for(EmbeddedTxtc embedList : embedList){
			size += embedList.getBinarySize(version);
		}
		for(TxtcEntry entry : entryList){
			size += entry.getBinarySize();
		}
		size += tgiTable.size() << 4;
		if(version >= 7) size++;
		if(version >= 8) size++;
		return size;
	}
	
	public FileBuffer writeBinary(boolean byteOrder, int fileVersion) {
		FileBuffer buff = new FileBuffer(getBinarySize(fileVersion), byteOrder);
		writeBinaryTo(buff, fileVersion);
		return buff;
	}
	
	public int writeBinaryTo(FileBuffer target, int fileVersion) {
		if(target == null) return 0;
		long stPos = target.getFileSize();
		
		int embedCount = embedList.size();
		int entryCount = entryList.size();
		int tgiCount = tgiTable.size();
		target.addToFile(fileVersion);
		
		//Calculate TGI table offset
		int tgiOffset = 13;
		for(TxtcEntry entry : entryList){
			tgiOffset += entry.getBinarySize();
		}
		if(fileVersion >= 8) tgiOffset++;
		if(fileVersion >= 7) {
			tgiOffset++;
			for(EmbeddedTxtc embedList : embedList){
				tgiOffset += embedList.getBinarySize(fileVersion);
			}
		}
		target.addToFile(tgiOffset);
		
		if (fileVersion >= 7){
			target.addToFile((byte)embedCount);
			for(EmbeddedTxtc embedList : embedList){
				embedList.writeBinaryTo(target, fileVersion);
			}
		}

		target.addToFile(patternSize);
		target.addToFile(partType);
		target.addToFile(reservedA);
		target.addToFile(entryCount);
		if (fileVersion >= 8) target.addToFile(reservedB);
		for(TxtcEntry entry : entryList){
			entry.writeBinaryTo(target);
		}
		target.addToFile((byte)tgiCount);
		for(MaxisResRef ref : tgiTable){
			MaxisResKey resourceKey = ref.getKey();
			resourceKey.writeBinIGT(target);
		}

		return (int)(target.getFileSize() - stPos);
	}

	public void writeXMLNode(Writer out, String indent, List<MaxisResRef> parentRefTable) throws IOException {
		writeXMLNode(out, indent, null, parentRefTable);
	}
	
	public void writeXMLNode(Writer out, String indent, String varName, List<MaxisResRef> parentRefTable) throws IOException {
		if(out == null) return;
		if(indent == null) indent = "";
		
		out.write(indent);
		out.write(String.format("<%s", XML_NODE_NAME));
		if(varName != null){
			out.write(String.format(" VarName=\"%s\"", varName));
		}
		
		out.write(String.format(" %s=\"%s\"", XMLKEY_PATTERNSIZE, PatternSize.stringFromValue(patternSize)));
		out.write(String.format(" %s=\"%s\"", XMLKEY_PARTTYPE, CASPartType.stringFromValue(partType)));
		//out.write(String.format(" %s=\"0x%02x\"", XMLKEY_RESERVEDA, reservedA));
		//out.write(String.format(" %s=\"0x%02x\"", XMLKEY_RESERVEDB, reservedB));
		out.write(">\n");
		
		List<MaxisResRef> refTable = tgiTable;
		if(tgiTable == null || tgiTable.isEmpty()) refTable = parentRefTable;
		
		int embedCount = embedList.size();
		if(embedCount > 0){
			out.write(indent + "\t<List");
			out.write(String.format(" VarName=\"%s\">\n", XMLKEY_EMBEDLIST));
			for(EmbeddedTxtc embed : embedList){
				embed.writeXMLNode(out, indent + "\t\t", null, refTable);
			}
			out.write(indent + "\t</List>\n");
		}
		
		int entryCount = entryList.size();
		if(entryCount > 0) {
			out.write(indent + "\t<List");
			out.write(String.format(" VarName=\"%s\">\n", XMLKEY_ENTRYLIST));
			for(TxtcEntry entry : entryList){
				entry.writeXMLNode(out, indent + "\t\t", null, refTable);
			}
			out.write(indent + "\t</List>\n");
		}
		
		int keyCount = tgiTable.size();
		if(keyCount > 0) {
			out.write(indent + "\t<List");
			out.write(String.format(" VarName=\"%s\">\n", XMLKEY_TGITABLE));
			/*for(MaxisResKey resourceKey : tgiTable){
				resourceKey.writeXMLNode(out, indent + "\t\t");
			}*/
			for(MaxisResRef resRef : tgiTable) {
				resRef.writeXMLNode(out, indent + "\t\t");
			}
			out.write(indent + "\t</List>\n");
		}
		
		out.write(indent);
		out.write(String.format("</%s>\n", XML_NODE_NAME));
	}

	/*----- Debug -----*/
	
	public static void main(String[] args) {
		String inpath = args[0];
		String outstem = args[1];
		
		try {
			FileBuffer infile = FileBuffer.createBuffer(inpath, false);
			TextureCompositor txtc = TextureCompositor.readBinary(infile.getReferenceAt(0L));
			
			String xmlpath = outstem + ".xml";
			BufferedWriter bw = new BufferedWriter(new FileWriter(xmlpath));
			bw.write("<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n");
			txtc.writeXMLNode(bw, "", null);
			bw.close();
			
			//Try to reserialize
			Document doc = XMLReader.readXMLStatic(xmlpath);
			NodeList nl = doc.getChildNodes();
			int nCount = nl.getLength();
			Element root = null;
			for(int i = 0; i < nCount; i++) {
				Node nn = nl.item(i);
				if(nn.getNodeType() == Node.ELEMENT_NODE) {
					Element child = (Element)nn;
					if(child.getTagName().equals(XML_NODE_NAME)) {
						root = child;
						break;
					}
				}
			}
			
			txtc = TextureCompositor.readXMLNode(root, null);
			String binpath = outstem + ".txtc";
			FileBuffer outbuff = txtc.writeBinary(false, DEFO_WRITE_VERSION);
			outbuff.writeFile(binpath);
		}
		catch(Exception ex) {
			ex.printStackTrace();
			System.exit(1);
		}
		
	}
	
}
