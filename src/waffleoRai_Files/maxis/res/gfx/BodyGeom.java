/*-----------------------------------------------------
 * Autogenerated Java class from XML definition.
 * Created Sat, 18 Jan 2025 20:51:57 -0600
 *-----------------------------------------------------*/

package waffleoRai_Files.maxis.res.gfx;

import java.io.IOException;
import java.io.Writer;
import java.util.ArrayList;
import java.util.List;

import org.w3c.dom.Element;

import waffleoRai_Containers.maxis.MaxisResKey;
import waffleoRai_Files.XMLReader;
import waffleoRai_Files.maxis.res.gfx.VertexData.VertexDataPoint;
import waffleoRai_Files.maxis.ts3enum.gfx.MeshVertexDataType;
import waffleoRai_Files.maxis.ts3enum.gfx.MeshVertexDataTypeGroup;
import waffleoRai_Utils.BufferReference;
import waffleoRai_Utils.FileBuffer;
import waffleoRai_Utils.StringUtils;

public class BodyGeom{
	
	public static final String XML_NODE_NAME = "BodyGeom";
	public static final int BASE_SIZE = 54;

	private static final String XMLKEY_EMBEDDEDMTNFID = "EmbeddedMTNFId";
	private static final String XMLKEY_MTNFEMBED = "MtnfEmbed";
	private static final String XMLKEY_MERGEGROUP = "MergeGroup";
	private static final String XMLKEY_SORTORDER = "SortOrder";
	private static final String XMLKEY_FORMATBLOCKS = "VtxFieldList";
	private static final String XMLKEY_VERTEXDATABLOCK = "VertexData";
	private static final String XMLKEY_FACEPOINTLIST = "FaceList";
	private static final String XMLKEY_SKCONREFINDEX = "SkconRefIndex";
	private static final String XMLKEY_BONEHASHTABLE = "BoneList";
	private static final String XMLKEY_TGITABLE = "TgiTable";

	public int embeddedMTNFId;
	public MaterialInfo mtnfEmbed;
	public int mergeGroup;
	public int sortOrder;
	public ArrayList<FormatBlock> formatBlocks = new ArrayList<FormatBlock>();
	public ArrayList<GeomVertex> vertexData = new ArrayList<GeomVertex>();
	public ArrayList<GeomFace> faceList = new ArrayList<GeomFace>();
	public int skconRefIndex;
	public ArrayList<Integer> boneTable = new ArrayList<Integer>();
	public ArrayList<MaxisResKey> tgiTable = new ArrayList<MaxisResKey>();

	/*----- Inner Classes -----*/

	public static class FormatBlock{
		
		public static final String XML_NODE_NAME = "FormatBlock";
		public static final int BASE_SIZE = 9;

		private static final String XMLKEY_DATATYPE = "DataType";
		private static final String XMLKEY_SUBTYPE = "SubType";
		private static final String XMLKEY_BYTESPERELEMENT = "BytesPerElement";

		public int dataType;
		public int subType;
		public byte bytesPerElement;
		
		/*----- Read -----*/
		
		protected boolean readBinary_internal(BufferReference dat) {
			if(dat == null) return false;
			
			dataType = dat.nextInt();
			subType = dat.nextInt();
			bytesPerElement = dat.nextByte();

			return true;
		}
		
		protected boolean readXMLNode_internal(Element xml_element) {
			if(xml_element == null) return false;
			String nn = xml_element.getNodeName();
			if(nn == null) return false;
			if(!nn.equals(XML_NODE_NAME)) return false;
			
			String aval = null;
			aval = xml_element.getAttribute(XMLKEY_DATATYPE);
			if(aval != null) dataType = MeshVertexDataType.valueFromString(aval);
			aval = xml_element.getAttribute(XMLKEY_SUBTYPE);
			if(aval != null) subType = MeshVertexDataTypeGroup.valueFromString(aval);
			aval = xml_element.getAttribute(XMLKEY_BYTESPERELEMENT);
			if(aval != null) bytesPerElement = (byte)StringUtils.parseUnsignedInt(aval);

			return true;
		}
		
		public static FormatBlock readBinary(BufferReference dat) {
			if(dat == null) return null;
			FormatBlock str = new FormatBlock();
			if(!str.readBinary_internal(dat)) return null;
			return str;
		}
		
		public static FormatBlock readXMLNode(Element xml_element) {
			if(xml_element == null) return null;
			FormatBlock str = new FormatBlock();
			if(!str.readXMLNode_internal(xml_element)) return null;
			return str;
		}
		
		/*----- Write -----*/
		
		public int getBinarySize() {return BASE_SIZE;}
		
		public FileBuffer writeBinary(boolean byteOrder) {
			FileBuffer buff = new FileBuffer(getBinarySize(), byteOrder);
			writeBinaryTo(buff);
			return buff;
		}
		
		public int writeBinaryTo(FileBuffer target) {
			if(target == null) return 0;
			long stPos = target.getFileSize();
			
			target.addToFile(dataType);
			target.addToFile(subType);
			target.addToFile(bytesPerElement);

			return (int)(target.getFileSize() - stPos);
		}
	
		public void writeXMLNode(Writer out, String indent) throws IOException {
			writeXMLNode(out, indent, null);
		}
		
		public void writeXMLNode(Writer out, String indent, String varName) throws IOException {
			if(out == null) return;
			if(indent == null) indent = "";
			
			out.write(indent);
			out.write(String.format("<%s", XML_NODE_NAME));
			if(varName != null){
				out.write(String.format(" VarName=\"%s\"", varName));
			}
			out.write(String.format(" %s=\"%s\"", XMLKEY_DATATYPE, MeshVertexDataType.stringFromValue(dataType)));
			out.write(String.format(" %s=\"%s\"", XMLKEY_SUBTYPE, MeshVertexDataTypeGroup.stringFromValue(subType)));
			out.write(String.format(" %s=\"0x%02x\"", XMLKEY_BYTESPERELEMENT, bytesPerElement));
			out.write("/>\n");

		}
	
	}

	public static class GeomVertex{
		
		public static final String XML_NODE_NAME = "GeomVertex";
		
		public ArrayList<VertexDataPoint> data = new ArrayList<VertexDataPoint>();
		
		protected boolean readXMLNode_internal(Element xml_element) {
			if(xml_element == null) return false;
			String nn = xml_element.getNodeName();
			if(nn == null) return false;
			if(!nn.equals(XML_NODE_NAME)) return false;
			
			List<Element> children = XMLReader.getChildElements(xml_element);
			for(Element child : children) {
				VertexDataPoint dp = VertexData.readXMLNode(child);
				if(dp != null) data.add(dp);
			}
			
			return true;
		}
		
		public static GeomVertex readXMLNode(Element xml_element) {
			if(xml_element == null) return null;
			GeomVertex str = new GeomVertex();
			if(!str.readXMLNode_internal(xml_element)) return null;
			return str;
		}
		
	}
	
	public static class GeomFace{
		public static final String XML_NODE_NAME = "GeomFace";
		
		public int[] vertices = new int[3];
		
		protected boolean readXMLNode_internal(Element xml_element) {
			if(xml_element == null) return false;
			String nn = xml_element.getNodeName();
			if(nn == null) return false;
			if(!nn.equals(XML_NODE_NAME)) return false;
			
			String aval = xml_element.getAttribute("Vertices");
			if(aval != null) {
				aval = aval.replace("{", "");
				aval = aval.replace("}", "");
				String[] spl = aval.split(",");
				for(int i = 0; i < 3; i++) {
					if(i >= spl.length) vertices[i] = 0;
					else {
						vertices[i] = StringUtils.parseUnsignedInt(spl[i].trim());
					}
				}
			}
			else return false;
			
			return true;
		}
		
		public static GeomFace readXMLNode(Element xml_element) {
			if(xml_element == null) return null;
			GeomFace str = new GeomFace();
			if(!str.readXMLNode_internal(xml_element)) return null;
			return str;
		}

		public void writeXMLNode(Writer out, String indent) throws IOException {
			if(out == null) return;
			if(indent == null) indent = "";
			
			out.write(indent + "<" + XML_NODE_NAME);
			out.write(String.format(" Vertices=\"{%d,%d,%d}\"", vertices[0], vertices[1], vertices[2]));
			out.write("/>\n");
		}
		
	}
	
	/*----- Read -----*/
	
	protected boolean readBinary_internal(BufferReference dat) {
		if(dat == null) return false;
		
		String magicno = dat.nextASCIIString(4);
		if(!magicno.equals("GEOM")) return false;
		
		dat.add(12L); //Skip tgi table info and version info
		
		embeddedMTNFId = dat.nextInt();
		if (embeddedMTNFId != 0){
			dat.add(4L); //Skip embed size
			mtnfEmbed = MaterialInfo.readBinary(dat);
		}
		mergeGroup = dat.nextInt();
		sortOrder = dat.nextInt();
		int vertexCount = dat.nextInt();
		int formatBlockCount = dat.nextInt();
		formatBlocks.ensureCapacity(formatBlockCount);
		for(int i = 0; i < formatBlockCount; i++){
			FormatBlock formatBlock = FormatBlock.readBinary(dat);
			if(formatBlock != null) formatBlocks.add(formatBlock);
		}
		vertexData.ensureCapacity(vertexCount);
		for(int i = 0; i < vertexCount; i++){
			GeomVertex vtx = new GeomVertex();
			for(FormatBlock fmt : formatBlocks) {
				VertexDataPoint vdat = VertexData.readVertexDataBlock(dat, fmt.dataType);
				vtx.data.add(vdat);
			}
			vertexData.add(vtx);
		}
		int itemCount = dat.nextInt();
		byte[] itemSizes = new byte[itemCount];
		for(int i = 0; i < itemCount; i++){
			itemSizes[i] = dat.nextByte();
		}
		
		int numFacePoints = dat.nextInt();
		int faceCount = numFacePoints/3;
		faceList.ensureCapacity(faceCount);
		for(int i = 0; i < faceCount; i++){
			GeomFace f = new GeomFace();
			for(int j = 0; j < 3; j++) {
				switch(itemSizes[0]) {
				case 1:
					f.vertices[j] = Byte.toUnsignedInt(dat.nextByte());
					break;
				case 2:
					f.vertices[j] = Short.toUnsignedInt(dat.nextShort());
					break;
				case 3:
					f.vertices[j] = dat.next24Bits();
					break;
				case 4:
					f.vertices[j] = dat.nextInt();
					break;
				}
			}
			faceList.add(f);
		}
		
		skconRefIndex = dat.nextInt();
		int boneEntryCount = dat.nextInt();
		boneTable.ensureCapacity(boneEntryCount);
		for(int i = 0; i < boneEntryCount; i++){
			Integer boneHash = dat.nextInt();
			if(boneHash != null) boneTable.add(boneHash);
		}
		
		int tgiCount = dat.nextByte();
		tgiTable.ensureCapacity(tgiCount);
		for(int i = 0; i < tgiCount; i++){
			MaxisResKey resKey = MaxisResKey.readBinTGI(dat);
			if(resKey != null) tgiTable.add(resKey);
		}

		return true;
	}
	
	protected boolean readXMLNode_internal(Element xml_element) {
		if(xml_element == null) return false;
		String nn = xml_element.getNodeName();
		if(nn == null) return false;
		if(!nn.equals(XML_NODE_NAME)) return false;
		
		String aval = null;
		Element child = null;

		aval = xml_element.getAttribute(XMLKEY_EMBEDDEDMTNFID);
		if(aval != null) embeddedMTNFId = StringUtils.parseUnsignedInt(aval);
		if (embeddedMTNFId != 0){
			child = XMLReader.getFirstChildElementWithTagAndAttribute(xml_element, "MaterialInfo", "VarName", XMLKEY_MTNFEMBED);
			if(child != null) mtnfEmbed = MaterialInfo.readXMLNode(child);
		}
		aval = xml_element.getAttribute(XMLKEY_MERGEGROUP);
		if(aval != null) mergeGroup = StringUtils.parseUnsignedInt(aval);
		aval = xml_element.getAttribute(XMLKEY_SORTORDER);
		if(aval != null) sortOrder = StringUtils.parseSignedInt(aval);

		child = XMLReader.getFirstChildElementWithTag(xml_element, XMLKEY_FORMATBLOCKS);
		if(child != null){
			List<Element> gclist = XMLReader.getChildElementsWithTag(child, XML_NODE_NAME);
			int fmtCount = gclist.size();
			if(fmtCount > 0) {
				formatBlocks.ensureCapacity(fmtCount);
				for(Element gc : gclist){
					formatBlocks.add(FormatBlock.readXMLNode(gc));
				}	
			}
		}
		
		child = XMLReader.getFirstChildElementWithTag(xml_element, XMLKEY_VERTEXDATABLOCK);
		if(child != null){
			List<Element> gclist = XMLReader.getChildElementsWithTag(child, GeomVertex.XML_NODE_NAME);
			int vertexCount = gclist.size();
			vertexData.ensureCapacity(vertexCount);
			if(vertexCount > 0) {
				for(Element gc : gclist){
					GeomVertex vtx = GeomVertex.readXMLNode(gc);
					if(vtx != null) vertexData.add(vtx);
				}
			}
		}
		
		//Faces
		child = XMLReader.getFirstChildElementWithTag(xml_element, XMLKEY_FACEPOINTLIST);
		if(child != null){
			List<Element> gclist = XMLReader.getChildElementsWithTag(child, GeomFace.XML_NODE_NAME);
			int faceCount = gclist.size();
			faceList.ensureCapacity(faceCount);
			if(faceCount > 0) {
				for(Element gc : gclist){
					GeomFace face = GeomFace.readXMLNode(gc);
					if(face != null) faceList.add(face);
				}
			}
		}
		
		aval = xml_element.getAttribute(XMLKEY_SKCONREFINDEX);
		if(aval != null) skconRefIndex = StringUtils.parseUnsignedInt(aval);
		
		child = XMLReader.getFirstChildElementWithTag(xml_element, XMLKEY_BONEHASHTABLE);
		if(child != null){
			List<Element> gclist = XMLReader.getChildElementsWithTag(child, "BoneEntry");
			int boneEntryCount = gclist.size();
			if(boneEntryCount > 0) {
				boneTable.ensureCapacity(boneEntryCount);
				for(Element gc : gclist){
					aval = gc.getAttribute("BoneId");
					if((aval != null) && !aval.isEmpty()) boneTable.add(StringUtils.parseSignedInt(aval));
				}	
			}
		}
		
		child = XMLReader.getFirstChildElementWithTagAndAttribute(xml_element, "List", "VarName", XMLKEY_TGITABLE);
		if(child != null){
			List<Element> gclist = XMLReader.getChildElementsWithTag(child, "MaxisResKey");
			int tgiCount = gclist.size();
			if(tgiCount > 0) {
				tgiTable.ensureCapacity(tgiCount);
				for(Element gc : gclist){
					tgiTable.add(MaxisResKey.readXMLNode(gc));
				}
			}
		}

		return true;
	}
	
	public static BodyGeom readBinary(BufferReference dat) {
		if(dat == null) return null;
		BodyGeom str = new BodyGeom();
		if(!str.readBinary_internal(dat)) return null;
		return str;
	}
	
	public static BodyGeom readXMLNode(Element xml_element) {
		if(xml_element == null) return null;
		BodyGeom str = new BodyGeom();
		if(!str.readXMLNode_internal(xml_element)) return null;
		return str;
	}
	
	/*----- Write -----*/
	
	public int getBinarySize() {
		int size = BASE_SIZE;
		if(embeddedMTNFId != 0) {
			size += 4 + mtnfEmbed.getBinarySize();
		}
		
		int vsize = 0;
		for(FormatBlock fmt : formatBlocks) {
			vsize += fmt.bytesPerElement;
		}
		size += formatBlocks.size() * FormatBlock.BASE_SIZE;
		size += vertexData.size() * vsize;
		
		int facePointSize = 2;
		if(vertexData.size() > 0xffff) facePointSize = 4;
		size += facePointSize * faceList.size();
		size += boneTable.size() << 2;
		size += tgiTable.size() << 4;
		
		return size;
	}
	
	public FileBuffer writeBinary(boolean byteOrder) {
		FileBuffer buff = new FileBuffer(getBinarySize(), byteOrder);
		writeBinaryTo(buff);
		return buff;
	}
	
	public int writeBinaryTo(FileBuffer target) {
		if(target == null) return 0;
		long stPos = target.getFileSize();
		
		//Calculate sizes
		int vertexCount = vertexData.size();
		int faceCount = faceList.size();
		int fieldCount = formatBlocks.size();
		int boneCount = boneTable.size();
		int refCount = tgiTable.size();
		
		int facePointSize = 2;
		if(vertexCount > 0xffff) facePointSize = 4;
		int vertexDataSize = 0;
		for(FormatBlock fmt : formatBlocks) {
			vertexDataSize += fmt.bytesPerElement;
		}
		int mtnfSize = 0;
		int refTableOffset = 8;
		if(mtnfEmbed != null) {
			mtnfSize = mtnfEmbed.getBinarySize();
			refTableOffset += 4 + mtnfSize;
		}
		refTableOffset += 16;
		refTableOffset += fieldCount * FormatBlock.BASE_SIZE;
		refTableOffset += vertexCount * vertexDataSize;
		refTableOffset += 9;
		refTableOffset += faceCount * facePointSize;
		refTableOffset += 8;
		refTableOffset += boneCount << 2;
		
		target.printASCIIToFile("GEOM");
		target.addToFile(refTableOffset);
		target.addToFile((refCount << 4) + 1);
		if(mtnfEmbed != null) {
			target.addToFile(embeddedMTNFId);
			target.addToFile(mtnfSize);
			mtnfEmbed.writeBinaryTo(target);
		}
		else target.addToFile(0);
		
		target.addToFile(mergeGroup);
		target.addToFile(sortOrder);
		target.addToFile(vertexCount);
		target.addToFile(fieldCount);
		for(FormatBlock fmt : formatBlocks) {
			fmt.writeBinaryTo(target);
		}
		for(GeomVertex vtx : vertexData) {
			//TODO Should probably add check to force fields/formats to match up for all vertices
			for(VertexDataPoint dp : vtx.data) {
				dp.writeBinaryTo(target);
			}
		}
		
		target.addToFile(1); //Item count
		target.addToFile((byte)facePointSize); //Item size
		target.addToFile(faceCount * 3);
		for(GeomFace face : faceList) {
			for(int i = 0; i < 3; i++) {
				switch(facePointSize) {
				case 1:
					target.addToFile((byte)face.vertices[i]);
					break;
				case 2:
					target.addToFile((short)face.vertices[i]);
					break;
				case 3:
					target.add24ToFile(face.vertices[i]);
					break;
				case 4:
					target.addToFile(face.vertices[i]);
					break;
				}
			}
		}
		
		target.addToFile(skconRefIndex);
		target.addToFile(boneCount);
		for(Integer b : boneTable) target.addToFile(b);
		target.addToFile((byte)refCount);
		for(MaxisResKey resKey : tgiTable){
			resKey.writeBinTGI(target);
		}

		return (int)(target.getFileSize() - stPos);
	}

	public void writeXMLNode(Writer out, String indent) throws IOException {
		writeXMLNode(out, indent, null);
	}
	
	public void writeXMLNode(Writer out, String indent, String varName) throws IOException {
		if(out == null) return;
		if(indent == null) indent = "";
		
		out.write(indent);
		out.write(String.format("<%s", XML_NODE_NAME));
		if(varName != null){
			out.write(String.format(" VarName=\"%s\"", varName));
		}
		
		if(mtnfEmbed == null) embeddedMTNFId = 0;
		out.write(String.format(" %s=\"0x%08x\"", XMLKEY_EMBEDDEDMTNFID, embeddedMTNFId));
		out.write(String.format(" %s=\"%d\"", XMLKEY_MERGEGROUP, mergeGroup));
		out.write(String.format(" %s=\"%d\"", XMLKEY_SORTORDER, sortOrder));
		out.write(String.format(" %s=\"%d\"", XMLKEY_SKCONREFINDEX, skconRefIndex));
		out.write(">\n");
		
		if(mtnfEmbed != null) {
			mtnfEmbed.writeXMLNode(out, indent + "\t", XMLKEY_MTNFEMBED);
		}
		
		out.write(indent + "\t<" + XMLKEY_FORMATBLOCKS + ">\n");
		for(FormatBlock fmt : formatBlocks) {
			fmt.writeXMLNode(out, indent + "\t\t");
		}
		out.write(indent + "\t</" + XMLKEY_FORMATBLOCKS + ">\n");
		
		out.write(indent + "\t<" + XMLKEY_VERTEXDATABLOCK + ">\n");
		for(GeomVertex vtx : vertexData) {
			out.write(indent + "\t\t<" + GeomVertex.XML_NODE_NAME + ">\n");
			for(VertexDataPoint dp : vtx.data) {
				dp.writeXMLNode(out, indent + "\t\t\t");
			}
			out.write(indent + "\t\t</" + GeomVertex.XML_NODE_NAME + ">\n");
		}
		out.write(indent + "\t</" + XMLKEY_VERTEXDATABLOCK + ">\n");
		
		out.write(indent + "\t<" + XMLKEY_FACEPOINTLIST + ">\n");
		for(GeomFace face : faceList) {
			face.writeXMLNode(out, indent + "\t\t");
		}
		out.write(indent + "\t</" + XMLKEY_FACEPOINTLIST + ">\n");
		
		out.write(indent + "\t<" + XMLKEY_BONEHASHTABLE + ">\n");
		for(Integer b : boneTable) {
			out.write(indent + "\t\t");
			out.write(String.format("<BoneEntry BoneId=\"0x%08x\"/>\n", b));
		}
		out.write(indent + "\t</" + XMLKEY_BONEHASHTABLE + ">\n");
		
		out.write(indent + "\t<List");
		out.write(String.format(" VarName=\"%s\">\n", XMLKEY_TGITABLE));
		for(MaxisResKey res : tgiTable) {
			res.writeXMLNode(out, indent + "\t\t");
		}
		out.write(indent + "\t</List>\n");

		out.write(String.format("</%s>\n", XML_NODE_NAME));

	}

}
