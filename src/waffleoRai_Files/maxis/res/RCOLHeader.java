/*-----------------------------------------------------
 * Autogenerated Java class from XML definition.
 * Created Fri, 17 Jan 2025 16:32:42 -0600
 *-----------------------------------------------------*/

package waffleoRai_Files.maxis.res;

import java.io.IOException;
import java.io.Writer;
import java.util.ArrayList;
import java.util.List;

import org.w3c.dom.Element;

import waffleoRai_Containers.maxis.MaxisResKey;
import waffleoRai_Files.XMLReader;
import waffleoRai_Utils.BufferReference;
import waffleoRai_Utils.FileBuffer;
import waffleoRai_Utils.StringUtils;

public class RCOLHeader{ 

	private static final String XMLKEY_FILEVERSION = "FileVersion";
	private static final String XMLKEY_INTERNALPUBLICCOUNT = "InternalPublicCount";
	private static final String XMLKEY_INDEX3 = "Index3";
	private static final String XMLKEY_EXTERNALCOUNT = "ExternalCount";
	private static final String XMLKEY_INTERNALCOUNT = "InternalCount";
	private static final String XMLKEY_INTERNALITGLIST = "InternalITGList";
	private static final String XMLKEY_EXTERNALITGLIST = "ExternalITGList";
	private static final String XMLKEY_INTERNALLOCTABLE = "InternalLocTable";

	public int fileVersion;
	public int internalPublicCount;
	public int index3;
	public int externalCount;
	public int internalCount;
	public ArrayList<MaxisResKey> internalITGList = new ArrayList<MaxisResKey>();
	public ArrayList<MaxisResKey> externalITGList = new ArrayList<MaxisResKey>();
	public ArrayList<InternalChunk> internalLocTable = new ArrayList<InternalChunk>();

	private String xmlNodeName;
	private int baseSize;

	public RCOLHeader() {
		xmlNodeName = "RCOLHeader";
		baseSize = 20;
	}
	
	/*----- Inner Classes -----*/

	public static class InternalChunk {

		private static final String XMLKEY_CHUNKPOSITION = "ChunkPosition";
		private static final String XMLKEY_CHUNKSIZE = "ChunkSize";

		public int chunkPosition;
		public int chunkSize;

		private String xmlNodeName;
		private int baseSize;
	
		public InternalChunk() {
			xmlNodeName = "InternalChunk";
			baseSize = 8;
		}
		
		/*----- Read -----*/
		
		protected boolean readBinary_internal(BufferReference dat) {
			if(dat == null) return false;
			chunkPosition = dat.nextInt();
			chunkSize = dat.nextInt();
			return true;
		}
		
		protected boolean readXMLNode_internal(Element xml_element) {
			if(xml_element == null) return false;
			String nn = xml_element.getNodeName();
			if(nn == null) return false;
			if(!nn.equals(xmlNodeName)) return false;
			
			String aval = null;
			aval = xml_element.getAttribute(XMLKEY_CHUNKPOSITION);
			if(aval != null) chunkPosition = StringUtils.parseUnsignedInt(aval);
			aval = xml_element.getAttribute(XMLKEY_CHUNKSIZE);
			if(aval != null) chunkSize = StringUtils.parseUnsignedInt(aval);

			return true;
		}
		
		public static InternalChunk readBinary(BufferReference dat) {
			if(dat == null) return null;
			InternalChunk str = new InternalChunk();
			if(!str.readBinary_internal(dat)) return null;
			return str;
		}
		
		public static InternalChunk readXMLNode(Element xml_element) {
			if(xml_element == null) return null;
			InternalChunk str = new InternalChunk();
			if(!str.readXMLNode_internal(xml_element)) return null;
			return str;
		}
		
		/*----- Write -----*/
		
		public int getBinarySize() {
			int size = baseSize;
			return size;
		}
		
		public FileBuffer writeBinary(boolean byteOrder) {
			FileBuffer buff = new FileBuffer(getBinarySize(), byteOrder);
			writeBinaryTo(buff);
			return buff;
		}
		
		public int writeBinaryTo(FileBuffer target) {
			if(target == null) return 0;
			long stPos = target.getFileSize();
			
			target.addToFile(chunkPosition);
			target.addToFile(chunkSize);

			return (int)(target.getFileSize() - stPos);
		}
	
		public void writeXMLNode(Writer out, String indent) throws IOException {
			writeXMLNode(out, indent, null);
		}
		
		public void writeXMLNode(Writer out, String indent, String varName) throws IOException {
			if(out == null) return;
			if(indent == null) indent = "";
			
			out.write(indent);
			out.write(String.format("<%s", xmlNodeName));
			if(varName != null){
				out.write(String.format(" VarName=\"%s\"", varName));
			}
			out.write(String.format(" %s=\"0x%08x\"", XMLKEY_CHUNKPOSITION, chunkPosition));
			out.write(String.format(" %s=\"0x%08x\"", XMLKEY_CHUNKSIZE, chunkSize));
			out.write("/>\n");

		}
	
	}

	/*----- Read -----*/
	
	protected boolean readBinary_internal(BufferReference dat) {
		if(dat == null) return false;
		
		fileVersion = dat.nextInt();
		internalPublicCount = dat.nextInt();
		index3 = dat.nextInt();
		externalCount = dat.nextInt();
		internalCount = dat.nextInt();
		internalITGList.ensureCapacity(internalCount);
		for(int i = 0; i < internalCount; i++){
			MaxisResKey resKey = MaxisResKey.readBinITG(dat);
			if(resKey != null) internalITGList.add(resKey);
		}
		externalITGList.ensureCapacity(externalCount);
		for(int i = 0; i < externalCount; i++){
			MaxisResKey resKey = MaxisResKey.readBinITG(dat);
			if(resKey != null) externalITGList.add(resKey);
		}
		internalLocTable.ensureCapacity(internalCount);
		for(int i = 0; i < internalCount; i++){
			InternalChunk internalLoc = InternalChunk.readBinary(dat);
			if(internalLocTable != null) internalLocTable.add(internalLoc);
		}

		return true;
	}
	
	protected boolean readXMLNode_internal(Element xml_element) {
		if(xml_element == null) return false;
		String nn = xml_element.getNodeName();
		if(nn == null) return false;
		if(!nn.equals(xmlNodeName)) return false;
		
		String aval = null;
		Element child = null;
		aval = xml_element.getAttribute(XMLKEY_FILEVERSION);
		if(aval != null) fileVersion = StringUtils.parseSignedInt(aval);
		aval = xml_element.getAttribute(XMLKEY_INTERNALPUBLICCOUNT);
		if(aval != null) internalPublicCount = StringUtils.parseSignedInt(aval);
		aval = xml_element.getAttribute(XMLKEY_INDEX3);
		if(aval != null) index3 = StringUtils.parseSignedInt(aval);
		aval = xml_element.getAttribute(XMLKEY_EXTERNALCOUNT);
		if(aval != null) externalCount = StringUtils.parseSignedInt(aval);
		aval = xml_element.getAttribute(XMLKEY_INTERNALCOUNT);
		if(aval != null) internalCount = StringUtils.parseSignedInt(aval);
		child = XMLReader.getFirstChildElementWithTagAndAttribute(xml_element, "List", "VarName", XMLKEY_INTERNALITGLIST);
		if(child != null){
			internalITGList.ensureCapacity(internalCount);
			List<Element> gclist = XMLReader.getChildElementsWithTag(child, "MaxisResKey");
			for(Element gc : gclist){
				internalITGList.add(MaxisResKey.readXMLNode(gc));
			}
		}
		child = XMLReader.getFirstChildElementWithTagAndAttribute(xml_element, "List", "VarName", XMLKEY_EXTERNALITGLIST);
		if(child != null){
			externalITGList.ensureCapacity(externalCount);
			List<Element> gclist = XMLReader.getChildElementsWithTag(child, "MaxisResKey");
			for(Element gc : gclist){
				externalITGList.add(MaxisResKey.readXMLNode(gc));
			}
		}
		child = XMLReader.getFirstChildElementWithTagAndAttribute(xml_element, "List", "VarName", XMLKEY_INTERNALLOCTABLE);
		if(child != null){
			internalLocTable.ensureCapacity(internalCount);
			List<Element> gclist = XMLReader.getChildElementsWithTag(child, "InternalChunk");
			for(Element gc : gclist){
				internalLocTable.add(InternalChunk.readXMLNode(gc));
			}
		}

		return true;
	}
	
	public static RCOLHeader readBinary(BufferReference dat) {
		if(dat == null) return null;
		RCOLHeader str = new RCOLHeader();
		if(!str.readBinary_internal(dat)) return null;
		return str;
	}
	
	public static RCOLHeader readXMLNode(Element xml_element) {
		if(xml_element == null) return null;
		RCOLHeader str = new RCOLHeader();
		if(!str.readXMLNode_internal(xml_element)) return null;
		return str;
	}
	
	/*----- Write -----*/
	
	public int getBinarySize() {
		int size = baseSize;
		size += internalITGList.size() << 4;
		size += externalITGList.size() << 4;
		for(InternalChunk internalLocTable : internalLocTable){
			size += internalLocTable.getBinarySize();
		}
		return size;
	}
	
	public FileBuffer writeBinary(boolean byteOrder) {
		FileBuffer buff = new FileBuffer(getBinarySize(), byteOrder);
		writeBinaryTo(buff);
		return buff;
	}
	
	public int writeBinaryTo(FileBuffer target) {
		if(target == null) return 0;
		long stPos = target.getFileSize();
		
		internalCount = internalITGList.size();
		externalCount = externalITGList.size();
		internalCount = internalLocTable.size();
		target.addToFile(fileVersion);
		target.addToFile(internalPublicCount);
		target.addToFile(index3);
		target.addToFile(externalCount);
		target.addToFile(internalCount);
		for(MaxisResKey resKey : internalITGList){
			resKey.writeBinITG(target);
		}
		for(MaxisResKey resKey : externalITGList){
			resKey.writeBinITG(target);
		}
		for(InternalChunk internalLocTable : internalLocTable){
			internalLocTable.writeBinaryTo(target);
		}

		return (int)(target.getFileSize() - stPos);
	}

	public void writeXMLNode(Writer out, String indent) throws IOException {
		writeXMLNode(out, indent, null);
	}
	
	public void writeXMLNode(Writer out, String indent, String varName) throws IOException {
		if(out == null) return;
		if(indent == null) indent = "";
		
		internalCount = internalITGList.size();
		externalCount = externalITGList.size();
		internalCount = internalLocTable.size();
		out.write(indent);
		out.write(String.format("<%s", xmlNodeName));
		if(varName != null){
			out.write(String.format(" VarName=\"%s\"", varName));
		}
		out.write(String.format(" %s=\"%d\"", XMLKEY_FILEVERSION, fileVersion));
		out.write(String.format(" %s=\"%d\"", XMLKEY_INTERNALPUBLICCOUNT, internalPublicCount));
		out.write(String.format(" %s=\"%d\"", XMLKEY_INDEX3, index3));
		out.write(String.format(" %s=\"%d\"", XMLKEY_EXTERNALCOUNT, externalCount));
		out.write(String.format(" %s=\"%d\"", XMLKEY_INTERNALCOUNT, internalCount));
		out.write(">\n");
		out.write(indent + "\t<List ");
		out.write(String.format(" VarName=\"%s\">\n", XMLKEY_INTERNALITGLIST));
		for(MaxisResKey resKey : internalITGList){
			resKey.writeXMLNode(out, indent + "\t\t");
		}
		out.write(indent + "\t</List>\n");
		out.write(indent + "\t<List ");
		out.write(String.format(" VarName=\"%s\">\n", XMLKEY_EXTERNALITGLIST));
		for(MaxisResKey resKey : externalITGList){
			resKey.writeXMLNode(out, indent + "\t\t");
		}
		out.write(indent + "\t</List>\n");
		out.write(indent + "\t<List ");
		out.write(String.format(" VarName=\"%s\">\n", XMLKEY_INTERNALLOCTABLE));
		for(InternalChunk internalLocTable : internalLocTable){
			internalLocTable.writeXMLNode(out, indent + "\t\t", null);
		}
		out.write(indent + "\t</List>\n");
		out.write(indent);
		out.write(String.format("</%s>\n", xmlNodeName));

	}

}
